diff --git a/src/Orchestrator/Services/DhtNodeService.cs b/src/Orchestrator/Services/DhtNodeService.cs
index 6f26a10..e97b9f0 100644
--- a/src/Orchestrator/Services/DhtNodeService.cs
+++ b/src/Orchestrator/Services/DhtNodeService.cs
@@ -20,6 +20,13 @@ public interface IDhtNodeService
     /// Returns addresses like "/ip4/{ip}/tcp/4001/p2p/{peerId}".
     /// </summary>
     Task<List<string>> GetBootstrapPeersAsync(string? excludeNodeId = null);
+
+    /// <summary>
+    /// Count of online nodes with Active DHT obligations whose PeerId hasn't been
+    /// reported yet. Non-zero means bootstrap peers will become available soon
+    /// (once heartbeat propagates the peer IDs).
+    /// </summary>
+    Task<int> GetPendingPeerIdCountAsync(string? excludeNodeId = null);
 }
 
 public class DhtNodeService : IDhtNodeService
@@ -152,26 +159,119 @@ public class DhtNodeService : IDhtNodeService
         var peers = new List<string>();
         var nodes = await _dataStore.GetAllNodesAsync();
 
+        // Track nodes that have Active DHT obligations but haven't reported PeerId yet.
+        // These are DHT VMs that are running but the heartbeat hasn't propagated the
+        // peer ID to the orchestrator — deploying now would produce empty bootstrap peers.
+        var pendingPeerIdCount = 0;
+
         foreach (var node in nodes)
         {
             if (node.Id == excludeNodeId) continue;
             if (node.Status != NodeStatus.Online) continue;
 
             var dhtObligation = node.SystemVmObligations
-                .FirstOrDefault(o => o.Role == SystemVmRole.Dht && o.Status == SystemVmStatus.Active);
+                .FirstOrDefault(o => o.Role == SystemVmRole.Dht);
 
             if (dhtObligation == null) continue;
-            if (node.DhtInfo == null || string.IsNullOrEmpty(node.DhtInfo.PeerId)) continue;
+
+            if (dhtObligation.Status != SystemVmStatus.Active)
+            {
+                _logger.LogDebug(
+                    "GetBootstrapPeers: skipping node {NodeId} — DHT obligation status is {Status} (not Active)",
+                    node.Id, dhtObligation.Status);
+                continue;
+            }
+
+            if (node.DhtInfo == null)
+            {
+                _logger.LogDebug(
+                    "GetBootstrapPeers: skipping node {NodeId} — DhtInfo is null despite Active obligation",
+                    node.Id);
+                pendingPeerIdCount++;
+                continue;
+            }
+
+            if (string.IsNullOrEmpty(node.DhtInfo.PeerId))
+            {
+                _logger.LogDebug(
+                    "GetBootstrapPeers: skipping node {NodeId} — DhtInfo.PeerId is empty " +
+                    "(DHT VM running but peerId not yet reported via heartbeat)",
+                    node.Id);
+                pendingPeerIdCount++;
+                continue;
+            }
 
             // Use ListenAddress which contains the WG tunnel IP the DHT node advertises
             var ip = node.DhtInfo.ListenAddress?.Split(':')[0] ?? GetAdvertiseIp(node);
             // libp2p multiaddr format
             peers.Add($"/ip4/{ip}/tcp/{DhtListenPort}/p2p/{node.DhtInfo.PeerId}");
+
+            _logger.LogDebug(
+                "GetBootstrapPeers: including node {NodeId} — peerId={PeerId}, addr={Ip}",
+                node.Id, node.DhtInfo.PeerId[..12], ip);
+        }
+
+        if (peers.Count == 0 && pendingPeerIdCount > 0)
+        {
+            _logger.LogWarning(
+                "GetBootstrapPeers: 0 usable peers but {PendingCount} node(s) have Active DHT " +
+                "obligations without PeerId — heartbeat may not have propagated yet",
+                pendingPeerIdCount);
         }
 
         return peers;
     }
 
+    /// <summary>
+    /// Number of online nodes with Active DHT obligations whose PeerId hasn't been
+    /// reported yet (DHT VM running, but heartbeat hasn't propagated the peer ID).
+    /// Used by the reconciliation service to defer deployment until bootstrap peers
+    /// are actually available.
+    ///
+    /// Safety valve: only counts obligations that became Active within the last 5 minutes.
+    /// After 5 minutes without PeerId, the DHT callback likely failed — stop waiting
+    /// and let the new node deploy (it will be the genesis node of a new cluster).
+    /// </summary>
+    public async Task<int> GetPendingPeerIdCountAsync(string? excludeNodeId = null)
+    {
+        var nodes = await _dataStore.GetAllNodesAsync();
+        var count = 0;
+        var maxWait = TimeSpan.FromMinutes(5);
+
+        foreach (var node in nodes)
+        {
+            if (node.Id == excludeNodeId) continue;
+            if (node.Status != NodeStatus.Online) continue;
+
+            // Check both Active (VM running, PeerId may be pending) and Deploying
+            // (VM just created, will become Active soon). Both indicate a peer is
+            // on its way and we should wait rather than deploying with empty bootstrap.
+            var dhtObligation = node.SystemVmObligations
+                .FirstOrDefault(o => o.Role == SystemVmRole.Dht &&
+                    o.Status is SystemVmStatus.Active or SystemVmStatus.Deploying);
+
+            if (dhtObligation == null) continue;
+            if (node.DhtInfo != null && !string.IsNullOrEmpty(node.DhtInfo.PeerId)) continue;
+
+            // Safety valve: if the obligation has been around for >5 min without PeerId,
+            // the DHT callback likely failed. Don't block other deployments waiting for it.
+            var referenceTime = dhtObligation.ActiveAt ?? dhtObligation.DeployedAt;
+            if (referenceTime.HasValue &&
+                (DateTime.UtcNow - referenceTime.Value) > maxWait)
+            {
+                _logger.LogWarning(
+                    "Node {NodeId} DHT obligation {Status} for >{MaxMin}min without PeerId — " +
+                    "callback may have failed, not blocking other deployments",
+                    node.Id, dhtObligation.Status, maxWait.TotalMinutes);
+                continue;
+            }
+
+            count++;
+        }
+
+        return count;
+    }
+
     /// <summary>
     /// Determine the IP that other nodes use to reach this node's DHT VM.
     /// Public nodes: use public IP.
diff --git a/src/Orchestrator/Services/SystemVm/SystemVmReconciliationService.cs b/src/Orchestrator/Services/SystemVm/SystemVmReconciliationService.cs
index 1781626..6d02216 100644
--- a/src/Orchestrator/Services/SystemVm/SystemVmReconciliationService.cs
+++ b/src/Orchestrator/Services/SystemVm/SystemVmReconciliationService.cs
@@ -141,6 +141,31 @@ public class SystemVmReconciliationService : BackgroundService
             return;
         }
 
+        // Bootstrap peer prerequisite: if other nodes have Active DHT obligations
+        // but haven't reported their PeerId yet (heartbeat hasn't propagated it),
+        // defer deployment so we don't boot with empty bootstrap peers.
+        // Without this, a race between node registration and heartbeat processing
+        // causes new DHT VMs to deploy without bootstrap peers, leaving them
+        // isolated from the network.
+        // Exception: if NO other node has a DHT obligation at all, this is the
+        // genesis node — deploy immediately with empty bootstrap (expected).
+        if (obligation.Role == SystemVmRole.Dht)
+        {
+            var pendingPeerIds = await _dhtNodeService.GetPendingPeerIdCountAsync(excludeNodeId: node.Id);
+            if (pendingPeerIds > 0)
+            {
+                var existingPeers = await _dhtNodeService.GetBootstrapPeersAsync(excludeNodeId: node.Id);
+                if (existingPeers.Count == 0)
+                {
+                    _logger.LogInformation(
+                        "Deferring DHT deploy on node {NodeId} — {PendingCount} node(s) have Active DHT " +
+                        "but PeerId not yet reported (waiting for heartbeat propagation)",
+                        node.Id, pendingPeerIds);
+                    return;
+                }
+            }
+        }
+
         // Guard: skip if another obligation for the same role is already Deploying or Active.
         // This prevents duplicate VMs when registration and the background loop race.
         var alreadyDeployed = node.SystemVmObligations.Any(o =>
