#!/usr/bin/env python3
"""
DeCloud Node CLI - Real WalletConnect v1 Implementation

Uses pywalletconnect library for proper WalletConnect protocol.
Works with MetaMask Mobile, Trust Wallet, Rainbow, and all WalletConnect-compatible wallets.

Usage:
    decloud-node login
    decloud-node status
    decloud-node logout
"""

import sys
import os
import time
import json
import hashlib
import socket
import subprocess
import signal
from datetime import datetime
from typing import Optional, Dict, Any
import argparse

# Check dependencies
try:
    import qrcode
    import requests
    from eth_account.messages import encode_defunct
    from eth_account import Account
    from web3 import Web3
    from pywalletconnect import WCClient, WCClientInvalidOption
except ImportError as e:
    missing = str(e).split("'")[1] if "'" in str(e) else str(e)
    print(f"Error: Missing required package: {missing}")
    print("\nPlease install dependencies:")
    print("  pip3 install web3 eth-account requests qrcode pillow pywalletconnect")
    sys.exit(1)

# =============================================================================
# CONFIGURATION
# =============================================================================

VERSION = "2.3.0"
DEFAULT_ORCHESTRATOR_URL = "https://decloud.stackfi.tech"

# File paths
CREDENTIALS_FILE = "/etc/decloud/credentials"
CONFIG_FILE = "/etc/decloud/config.json"

# WalletConnect configuration
WC_BRIDGE_URL = "https://bridge.walletconnect.org"  # Official WalletConnect bridge
WC_TIMEOUT = 300  # 5 minutes

# =============================================================================
# TERMINAL COLORS
# =============================================================================

class Colors:
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[1;33m'
    BLUE = '\033[0;34m'
    CYAN = '\033[0;36m'
    MAGENTA = '\033[0;35m'
    BOLD = '\033[1m'
    NC = '\033[0m'

# =============================================================================
# LOGGING FUNCTIONS
# =============================================================================

def print_banner():
    """Print CLI banner"""
    print()
    print(f"{Colors.CYAN}{'='*70}{Colors.NC}")
    print(f"{Colors.BOLD}      üîê DeCloud Node Authentication (WalletConnect){Colors.NC}")
    print(f"{Colors.CYAN}{'='*70}{Colors.NC}")
    print()

def log_info(msg):
    print(f"{Colors.BLUE}‚Ñπ{Colors.NC} {msg}")

def log_success(msg):
    print(f"{Colors.GREEN}‚úì{Colors.NC} {msg}")

def log_error(msg):
    print(f"{Colors.RED}‚úó{Colors.NC} {msg}", file=sys.stderr)

def log_warn(msg):
    print(f"{Colors.YELLOW}‚ö†{Colors.NC} {msg}")

# =============================================================================
# SYSTEM INFORMATION FUNCTIONS
# =============================================================================

def get_node_id() -> str:
    """Generate deterministic node ID based on hardware"""
    try:
        cpu_info = ""
        if os.path.exists('/proc/cpuinfo'):
            with open('/proc/cpuinfo', 'r') as f:
                cpu_info = f.read()
        
        machine_id = ""
        if os.path.exists('/etc/machine-id'):
            with open('/etc/machine-id', 'r') as f:
                machine_id = f.read().strip()
        
        hostname = socket.gethostname()
        data = f"{cpu_info}{machine_id}{hostname}"
        node_hash = hashlib.sha256(data.encode()).hexdigest()[:16]
        
        return f"node-{hostname}-{node_hash}"
    except Exception as e:
        log_error(f"Failed to generate node ID: {e}")
        sys.exit(1)

def get_hardware_info() -> Dict[str, Any]:
    """Get hardware information"""
    def run_cmd(cmd):
        try:
            return subprocess.check_output(cmd, shell=True, text=True).strip()
        except:
            return "Unknown"
    
    cpu_model = run_cmd("lscpu | grep 'Model name' | cut -d':' -f2 | xargs")
    cpu_cores = run_cmd("nproc")
    memory_gb = run_cmd("free -g | awk '/^Mem:/{print $2}'")
    disk_gb = run_cmd("df -BG / | awk 'NR==2{print $2}' | tr -d 'G'")
    
    return {
        "cpu": cpu_model or "Unknown CPU",
        "cores": int(cpu_cores) if cpu_cores.isdigit() else 0,
        "memory": int(memory_gb) if memory_gb.isdigit() else 0,
        "disk": int(disk_gb) if disk_gb.isdigit() else 0,
        "hostname": socket.gethostname()
    }

def get_public_ip() -> str:
    """Get public IP address"""
    try:
        response = requests.get('https://api.ipify.org', timeout=5)
        return response.text.strip()
    except:
        return "Unknown"

# =============================================================================
# CONFIGURATION MANAGEMENT
# =============================================================================

def load_config() -> Dict[str, Any]:
    """Load configuration from file"""
    if os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, 'r') as f:
            return json.load(f)
    return {}

def save_config(config: Dict[str, Any]):
    """Save configuration to file"""
    os.makedirs(os.path.dirname(CONFIG_FILE), exist_ok=True)
    with open(CONFIG_FILE, 'w') as f:
        json.dump(config, f, indent=2)
    os.chmod(CONFIG_FILE, 0o600)

def load_credentials() -> Optional[Dict[str, str]]:
    """Load saved credentials"""
    if not os.path.exists(CREDENTIALS_FILE):
        return None
    
    credentials = {}
    with open(CREDENTIALS_FILE, 'r') as f:
        for line in f:
            if '=' in line:
                key, value = line.strip().split('=', 1)
                credentials[key] = value
    
    return credentials if credentials else None

def save_credentials(node_id: str, api_key: str, wallet_address: str, signature: str, message: str):
    """Save credentials to file"""
    os.makedirs(os.path.dirname(CREDENTIALS_FILE), exist_ok=True)
    
    with open(CREDENTIALS_FILE, 'w') as f:
        f.write(f"NODE_ID={node_id}\n")
        f.write(f"WALLET_ADDRESS={wallet_address}\n")
        f.write(f"API_KEY={api_key}\n")
        f.write(f"SIGNATURE={signature}\n")
        f.write(f"MESSAGE={message}\n")
        f.write(f"AUTHORIZED_AT={datetime.utcnow().isoformat()}\n")
    
    os.chmod(CREDENTIALS_FILE, 0o600)
    log_success(f"Credentials saved to {CREDENTIALS_FILE}")

# =============================================================================
# MESSAGE CREATION
# =============================================================================

def create_signing_message(node_id: str, wallet_address: str, hardware: Dict[str, Any]) -> str:
    """Create message to be signed by wallet"""
    timestamp = int(time.time())
    
    message = f"""Sign this message to authorize your DeCloud node:

Node ID: {node_id}
Wallet: {wallet_address}
Hardware: {hardware['cpu']}
Resources: {hardware['cores']} cores / {hardware['memory']}GB RAM
Timestamp: {timestamp}

This signature proves you own this wallet and authorizes the node to operate on your behalf.

NO FUNDS WILL BE TRANSFERRED - This is only for node authorization."""
    
    return message

# =============================================================================
# QR CODE GENERATION
# =============================================================================

def display_qr_code(uri: str, title: str = "Scan with WalletConnect-compatible wallet"):
    """Display QR code in terminal"""
    qr = qrcode.QRCode(
        version=1,
        error_correction=qrcode.constants.ERROR_CORRECT_L,
        box_size=1,
        border=2,
    )
    qr.add_data(uri)
    qr.make(fit=True)
    
    print()
    print(f"{Colors.BOLD}{Colors.CYAN}{title}{Colors.NC}")
    print()
    qr.print_ascii(invert=True)
    print()

# =============================================================================
# SIGNATURE VERIFICATION
# =============================================================================

def verify_signature(message: str, signature: str, expected_address: str) -> bool:
    """Verify that signature matches expected address"""
    try:
        encoded_message = encode_defunct(text=message)
        recovered_address = Account.recover_message(encoded_message, signature=signature)
        return recovered_address.lower() == expected_address.lower()
    except Exception as e:
        log_error(f"Signature verification failed: {e}")
        return False

# =============================================================================
# WALLETCONNECT IMPLEMENTATION
# =============================================================================

class WalletConnectAuth:
    """WalletConnect authentication handler"""
    
    def __init__(self):
        self.client = None
        self.connected = False
        self.accounts = []
        self.chain_id = None
        self.signature = None
        self.signature_error = None
        
    def on_session_request(self, data):
        """Called when wallet wants to establish session"""
        log_info("Session request received from wallet...")
        return True  # Approve the session
    
    def on_connect(self, accounts, chain_id):
        """Called when wallet connects"""
        self.connected = True
        self.accounts = accounts
        self.chain_id = chain_id
        log_success(f"Wallet connected!")
        log_info(f"Address: {accounts[0]}")
        log_info(f"Chain ID: {chain_id}")
    
    def on_disconnect(self):
        """Called when wallet disconnects"""
        log_warn("Wallet disconnected")
        self.connected = False
    
    def on_sign_result(self, signature):
        """Called when signature is received"""
        self.signature = signature
        log_success("Signature received from wallet!")
    
    def on_sign_error(self, error):
        """Called when signing fails"""
        self.signature_error = str(error)
        log_error(f"Signing failed: {error}")
    
    def connect_wallet(self, timeout=WC_TIMEOUT) -> Optional[str]:
        """
        Establish WalletConnect session and return wallet address
        Returns wallet address if successful, None otherwise
        """
        try:
            # Create WalletConnect client
            log_info("Initializing WalletConnect...")
            
            self.client = WCClient(bridge=WC_BRIDGE_URL)
            
            # Set up event handlers
            self.client.on_session_request = self.on_session_request
            self.client.on_connect = self.on_connect
            self.client.on_disconnect = self.on_disconnect
            
            # Get WalletConnect URI
            uri = self.client.get_connection_uri()
            
            # Display QR code
            print()
            print(f"{Colors.BOLD}{'‚ïê'*70}{Colors.NC}")
            print(f"{Colors.BOLD}           Scan QR Code with Your Mobile Wallet{Colors.NC}")
            print(f"{Colors.BOLD}{'‚ïê'*70}{Colors.NC}")
            
            display_qr_code(uri)
            
            print(f"{Colors.BOLD}Compatible Wallets:{Colors.NC}")
            print("  ‚Ä¢ MetaMask Mobile")
            print("  ‚Ä¢ Trust Wallet")
            print("  ‚Ä¢ Rainbow Wallet")
            print("  ‚Ä¢ Coinbase Wallet")
            print("  ‚Ä¢ Any WalletConnect-compatible wallet")
            print()
            print(f"{Colors.YELLOW}‚è±  Waiting for wallet connection...{Colors.NC}")
            print(f"   (Timeout: {timeout//60} minutes)")
            print()
            
            # Wait for connection
            start_time = time.time()
            while not self.connected and (time.time() - start_time) < timeout:
                time.sleep(0.5)
            
            if not self.connected:
                log_error("Connection timeout - wallet did not connect")
                return None
            
            if not self.accounts or len(self.accounts) == 0:
                log_error("No accounts received from wallet")
                return None
            
            return self.accounts[0]
        
        except Exception as e:
            log_error(f"WalletConnect error: {e}")
            return None
    
    def request_signature(self, message: str, address: str, timeout=WC_TIMEOUT) -> Optional[str]:
        """
        Request signature from connected wallet
        Returns signature if successful, None otherwise
        """
        try:
            if not self.connected:
                log_error("Wallet not connected")
                return None
            
            log_info("Requesting signature from wallet...")
            print()
            print(f"{Colors.BOLD}{'‚ïê'*70}{Colors.NC}")
            print(f"{Colors.BOLD}           Check Your Mobile Wallet{Colors.NC}")
            print(f"{Colors.BOLD}{'‚ïê'*70}{Colors.NC}")
            print()
            print("  A signing request has been sent to your wallet.")
            print("  Please review and approve the signature on your phone.")
            print()
            print(f"{Colors.YELLOW}‚è±  Waiting for signature...{Colors.NC}")
            print()
            
            # Request personal signature
            self.client.personal_sign(
                message=message,
                address=address,
                on_success=self.on_sign_result,
                on_error=self.on_sign_error
            )
            
            # Wait for signature
            start_time = time.time()
            while self.signature is None and self.signature_error is None and (time.time() - start_time) < timeout:
                time.sleep(0.5)
            
            if self.signature_error:
                log_error(f"Signing failed: {self.signature_error}")
                return None
            
            if self.signature is None:
                log_error("Signature timeout - user did not sign")
                return None
            
            return self.signature
        
        except Exception as e:
            log_error(f"Signature request error: {e}")
            return None
    
    def disconnect(self):
        """Disconnect WalletConnect session"""
        if self.client:
            try:
                self.client.disconnect()
            except:
                pass

# =============================================================================
# REGISTRATION
# =============================================================================

def register_node(orchestrator_url: str, node_id: str, wallet_address: str, 
                 signature: str, message: str, hardware: Dict[str, Any]) -> Optional[str]:
    """Register node with orchestrator and get API key"""
    try:
        response = requests.post(
            f"{orchestrator_url}/api/nodes/register",
            json={
                "nodeId": node_id,
                "walletAddress": wallet_address,
                "signature": signature,
                "message": message,
                "hardwareInfo": hardware,
                "publicIp": get_public_ip()
            },
            timeout=30
        )
        
        if response.status_code == 200:
            data = response.json()
            if data.get("success"):
                api_key = data.get("data", {}).get("apiKey")
                if not api_key:
                    api_key = data.get("apiKey")
                
                if api_key:
                    return api_key
                else:
                    log_error("API key not found in response")
                    return None
        
        log_error(f"Registration failed: {response.status_code}")
        if response.text:
            log_error(response.text[:200])
        
        return None
    
    except Exception as e:
        log_error(f"Failed to register node: {e}")
        return None

# =============================================================================
# WALLETCONNECT AUTHENTICATION FLOW
# =============================================================================

def login_with_walletconnect(orchestrator_url: str, verbose: bool = False):
    """Login using WalletConnect"""
    print_banner()
    
    # Get node information
    node_id = get_node_id()
    hardware = get_hardware_info()
    
    log_info(f"Node ID: {node_id}")
    log_info(f"Hardware: {hardware['cpu']}")
    log_info(f"Resources: {hardware['cores']} cores / {hardware['memory']}GB RAM / {hardware['disk']}GB disk")
    print()
    
    # Initialize WalletConnect
    wc_auth = WalletConnectAuth()
    
    # Set up signal handler for clean exit
    def signal_handler(sig, frame):
        print()
        log_warn("Interrupted by user")
        wc_auth.disconnect()
        sys.exit(1)
    
    signal.signal(signal.SIGINT, signal_handler)
    
    try:
        # Step 1: Connect wallet
        wallet_address = wc_auth.connect_wallet()
        
        if not wallet_address:
            log_error("Failed to connect wallet")
            return False
        
        print()
        
        # Step 2: Create signing message
        message = create_signing_message(node_id, wallet_address, hardware)
        
        # Step 3: Request signature
        signature = wc_auth.request_signature(message, wallet_address)
        
        if not signature:
            log_error("Failed to get signature")
            wc_auth.disconnect()
            return False
        
        print()
        
        # Step 4: Verify signature
        log_info("Verifying signature...")
        if not verify_signature(message, signature, wallet_address):
            log_error("Signature verification failed!")
            wc_auth.disconnect()
            return False
        
        log_success("Signature verified!")
        print()
        
        # Step 5: Register with orchestrator
        log_info("Registering with orchestrator...")
        
        api_key = register_node(
            orchestrator_url=orchestrator_url,
            node_id=node_id,
            wallet_address=wallet_address,
            signature=signature,
            message=message,
            hardware=hardware
        )
        
        if api_key:
            # Save credentials
            save_credentials(node_id, api_key, wallet_address, signature, message)
            
            # Save orchestrator URL to config
            config = load_config()
            config['orchestrator_url'] = orchestrator_url
            save_config(config)
            
            # Disconnect WalletConnect
            wc_auth.disconnect()
            
            print()
            print(f"{Colors.GREEN}{'‚ïê'*70}{Colors.NC}")
            print(f"{Colors.BOLD}              ‚úÖ Node Authorized Successfully!{Colors.NC}")
            print(f"{Colors.GREEN}{'‚ïê'*70}{Colors.NC}")
            print()
            print(f"  Node ID:      {node_id}")
            print(f"  Wallet:       {wallet_address}")
            print(f"  Credentials:  {CREDENTIALS_FILE}")
            print()
            print("The node agent will start automatically.")
            print("Check status with: systemctl status decloud-node-agent")
            print()
            
            return True
        else:
            log_error("Failed to register node with orchestrator")
            wc_auth.disconnect()
            return False
    
    except Exception as e:
        log_error(f"Authentication error: {e}")
        if wc_auth:
            wc_auth.disconnect()
        return False

# =============================================================================
# COMMAND HANDLERS
# =============================================================================

def cmd_login(args):
    """Handle login command"""
    creds = load_credentials()
    if creds and not args.force:
        log_warn("Node already authorized")
        print()
        print(f"  Node ID:  {creds.get('NODE_ID', 'Unknown')}")
        print(f"  Wallet:   {creds.get('WALLET_ADDRESS', 'Unknown')}")
        print(f"  API Key:  {creds.get('API_KEY', 'Unknown')[:20]}...")
        print()
        print("Use --force to re-authorize")
        return
    
    orchestrator_url = args.orchestrator
    if not orchestrator_url:
        config = load_config()
        orchestrator_url = config.get('orchestrator_url', DEFAULT_ORCHESTRATOR_URL)
    
    success = login_with_walletconnect(orchestrator_url, args.verbose)
    sys.exit(0 if success else 1)

def cmd_status(args):
    """Handle status command"""
    print_banner()
    
    creds = load_credentials()
    if not creds:
        log_warn("Node not authorized")
        print()
        print("Run: decloud-node login")
        return
    
    print(f"{Colors.BOLD}Node Status:{Colors.NC}")
    print()
    print(f"  Node ID:       {creds.get('NODE_ID', 'Unknown')}")
    print(f"  Wallet:        {creds.get('WALLET_ADDRESS', 'Unknown')}")
    print(f"  API Key:       {creds.get('API_KEY', 'Unknown')[:20]}...")
    print(f"  Authorized:    {creds.get('AUTHORIZED_AT', 'Unknown')}")
    print()
    
    try:
        result = subprocess.run(
            ['systemctl', 'is-active', 'decloud-node-agent'],
            capture_output=True,
            text=True
        )
        
        if result.stdout.strip() == 'active':
            log_success("Node agent is running")
        else:
            log_warn("Node agent is not running")
            print("Start with: sudo systemctl start decloud-node-agent")
    except:
        log_warn("Could not check service status")

def cmd_logout(args):
    """Handle logout command"""
    print_banner()
    
    creds = load_credentials()
    if not creds:
        log_info("Node not authorized - nothing to do")
        return
    
    log_warn(f"This will remove authorization for node: {creds.get('NODE_ID', 'Unknown')}")
    
    if not args.force:
        response = input("Continue? (y/N): ")
        if response.lower() != 'y':
            log_info("Cancelled")
            return
    
    if os.path.exists(CREDENTIALS_FILE):
        os.remove(CREDENTIALS_FILE)
        log_success("Credentials removed")
    
    try:
        subprocess.run(['systemctl', 'stop', 'decloud-node-agent'], check=False)
        log_success("Node agent stopped")
    except:
        pass
    
    print()
    log_info("Node logged out successfully")
    print("Run 'decloud-node login' to authorize again")

def cmd_version(args):
    """Handle version command"""
    print(f"DeCloud Node CLI v{VERSION} (WalletConnect)")

# =============================================================================
# MAIN ENTRY POINT
# =============================================================================

def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description="DeCloud Node CLI - WalletConnect Authentication",
        epilog="For support, visit: https://docs.decloud.io"
    )
    
    subparsers = parser.add_subparsers(dest='command', help='Command to execute')
    
    # Login command
    login_parser = subparsers.add_parser('login', help='Login with WalletConnect')
    login_parser.add_argument('--orchestrator', help='Orchestrator URL (optional)')
    login_parser.add_argument('--force', action='store_true', help='Force re-authorization')
    login_parser.add_argument('--verbose', action='store_true', help='Verbose output')
    
    # Status command
    status_parser = subparsers.add_parser('status', help='Show node status')
    
    # Logout command
    logout_parser = subparsers.add_parser('logout', help='Logout and remove credentials')
    logout_parser.add_argument('--force', action='store_true', help='Skip confirmation')
    
    # Version command
    version_parser = subparsers.add_parser('version', help='Show version')
    
    args = parser.parse_args()
    
    # Check root for login/logout
    if os.geteuid() != 0 and args.command in ['login', 'logout']:
        log_error("This command must be run as root (use sudo)")
        sys.exit(1)
    
    # Execute command
    if args.command == 'login':
        cmd_login(args)
    elif args.command == 'status':
        cmd_status(args)
    elif args.command == 'logout':
        cmd_logout(args)
    elif args.command == 'version':
        cmd_version(args)
    else:
        parser.print_help()

if __name__ == '__main__':
    main()