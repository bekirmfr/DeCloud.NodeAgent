#!/usr/bin/env python3
"""
DeCloud Node CLI - Web-Based WalletConnect Authentication

Uses a web page with proper WalletConnect integration for mobile signing.
The QR code contains a URL that opens the signing page on any device.

Usage:
    decloud-node login
    decloud-node status
    decloud-node logout
"""

import sys
import os
import time
import json
import hashlib
import socket
import subprocess
import base64
import urllib.parse
import uuid
from datetime import datetime
from typing import Optional, Dict, Any
import argparse

# Check dependencies
try:
    import qrcode
    import requests
    from eth_account.messages import encode_defunct
    from eth_account import Account
    from web3 import Web3
except ImportError as e:
    print(f"Error: Missing required package: {e}")
    print("\nPlease install dependencies:")
    print("  pip3 install web3 eth-account requests qrcode pillow")
    sys.exit(1)

# =============================================================================
# CONFIGURATION
# =============================================================================

VERSION = "2.3.0"
DEFAULT_ORCHESTRATOR_URL = "https://decloud.stackfi.tech"

# Signing page URL (you'll host this)
SIGNING_PAGE_URL = "https://decloud.stackfi.tech/sign.html"
# Alternative: Use localhost for testing
# SIGNING_PAGE_URL = "http://localhost:8000/sign.html"

# File paths
CREDENTIALS_FILE = "/etc/decloud/credentials"
CONFIG_FILE = "/etc/decloud/config.json"

# =============================================================================
# TERMINAL COLORS
# =============================================================================

class Colors:
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[1;33m'
    BLUE = '\033[0;34m'
    CYAN = '\033[0;36m'
    MAGENTA = '\033[0;35m'
    BOLD = '\033[1m'
    NC = '\033[0m'

# =============================================================================
# LOGGING FUNCTIONS
# =============================================================================

def print_banner():
    """Print CLI banner"""
    print()
    print(f"{Colors.CYAN}{'='*70}{Colors.NC}")
    print(f"{Colors.BOLD}      üîê DeCloud Node Authentication (WalletConnect){Colors.NC}")
    print(f"{Colors.CYAN}{'='*70}{Colors.NC}")
    print()

def log_info(msg):
    print(f"{Colors.BLUE}‚Ñπ{Colors.NC} {msg}")

def log_success(msg):
    print(f"{Colors.GREEN}‚úì{Colors.NC} {msg}")

def log_error(msg):
    print(f"{Colors.RED}‚úó{Colors.NC} {msg}", file=sys.stderr)

def log_warn(msg):
    print(f"{Colors.YELLOW}‚ö†{Colors.NC} {msg}")

# =============================================================================
# SYSTEM INFORMATION FUNCTIONS
# =============================================================================

def get_machine_id() -> str:
    """Get machine ID from /etc/machine-id"""
    try:
        if os.path.exists('/etc/machine-id'):
            with open('/etc/machine-id', 'r') as f:
                machine_id = f.read().strip()
                if machine_id:
                    return machine_id
        
        log_error("Could not read /etc/machine-id")
        sys.exit(1)
    except Exception as e:
        log_error(f"Failed to get machine ID: {e}")
        sys.exit(1)

def get_hardware_info() -> Dict[str, Any]:
    """Get hardware information"""
    def run_cmd(cmd):
        try:
            return subprocess.check_output(cmd, shell=True, text=True).strip()
        except:
            return "Unknown"
    
    cpu_model = run_cmd("lscpu | grep 'Model name' | cut -d':' -f2 | xargs")
    cpu_cores = run_cmd("nproc")
    memory_gb = run_cmd("free -g | awk '/^Mem:/{print $2}'")
    disk_gb = run_cmd("df -BG / | awk 'NR==2{print $2}' | tr -d 'G'")
    
    return {
        "cpu": cpu_model or "Unknown CPU",
        "cores": int(cpu_cores) if cpu_cores.isdigit() else 0,
        "memory": int(memory_gb) if memory_gb.isdigit() else 0,
        "disk": int(disk_gb) if disk_gb.isdigit() else 0,
        "hostname": socket.gethostname()
    }

def get_public_ip() -> str:
    """Get public IP address"""
    try:
        response = requests.get('https://api.ipify.org', timeout=5)
        return response.text.strip()
    except:
        return "Unknown"

# =============================================================================
# CONFIGURATION MANAGEMENT
# =============================================================================

def load_config() -> Dict[str, Any]:
    """Load configuration from file"""
    if os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, 'r') as f:
            return json.load(f)
    return {}

def save_config(config: Dict[str, Any]):
    """Save configuration to file"""
    os.makedirs(os.path.dirname(CONFIG_FILE), exist_ok=True)
    with open(CONFIG_FILE, 'w') as f:
        json.dump(config, f, indent=2)
    os.chmod(CONFIG_FILE, 0o600)

def load_credentials() -> Optional[Dict[str, str]]:
    """Load saved credentials"""
    if not os.path.exists(CREDENTIALS_FILE):
        return None
    
    credentials = {}
    with open(CREDENTIALS_FILE, 'r') as f:
        for line in f:
            if '=' in line:
                key, value = line.strip().split('=', 1)
                credentials[key] = value
    
    return credentials if credentials else None

def save_credentials(node_id: str, api_key: str, wallet_address: str, signature: str, message: str):
    """Save credentials to file"""
    os.makedirs(os.path.dirname(CREDENTIALS_FILE), exist_ok=True)
    
    with open(CREDENTIALS_FILE, 'w') as f:
        f.write(f"NODE_ID={node_id}\n")
        f.write(f"WALLET_ADDRESS={wallet_address}\n")
        f.write(f"API_KEY={api_key}\n")
        f.write(f"SIGNATURE={signature}\n")
        f.write(f"MESSAGE={message}\n")
        f.write(f"AUTHORIZED_AT={datetime.utcnow().isoformat()}\n")
    
    os.chmod(CREDENTIALS_FILE, 0o600)
    log_success(f"Credentials saved to {CREDENTIALS_FILE}")

# =============================================================================
# SIGNING URL GENERATION
# =============================================================================

def create_signing_message(machine_id: str, wallet_address: str, hardware: Dict[str, Any]) -> str:
    """Create message to be signed (NO node_id needed!)"""
    timestamp = int(time.time())
    
    message = f"""Sign this message to authorize your DeCloud node:

Machine ID: {machine_id}
Wallet: {wallet_address}
Hardware: {hardware['cpu']}
Resources: {hardware['cores']} cores / {hardware['memory']}GB RAM
Timestamp: {timestamp}

This signature proves you own this wallet and authorizes the node to operate on your behalf.

NO FUNDS WILL BE TRANSFERRED - This is only for node authorization."""
    
    return message

def generate_signing_url(message: str, wallet_address: str, hardware: Dict[str, Any]) -> str:
    """
    Generate URL to signing page with parameters
    
    Format: https://decloud.stackfi.tech/sign.html?message=base64&wallet=0x...&hardware=Intel
    """
    # Encode message to base64 for URL
    message_b64 = base64.b64encode(message.encode()).decode()
    
    # Build URL parameters
    params = {
        'message': message_b64,
        'wallet': wallet_address,
        'hardware': hardware['cpu'][:50]  # Truncate hardware name
    }
    
    # Create full URL
    url = f"{SIGNING_PAGE_URL}?{urllib.parse.urlencode(params)}"
    
    return url

def display_qr_code(data: str, title: str = "Scan to sign"):
    """Display QR code in terminal"""
    qr = qrcode.QRCode(
        version=1,
        error_correction=qrcode.constants.ERROR_CORRECT_L,
        box_size=1,
        border=2,
    )
    qr.add_data(data)
    qr.make(fit=True)
    
    print()
    print(f"{Colors.BOLD}{Colors.CYAN}{title}{Colors.NC}")
    print()
    qr.print_ascii(invert=True)
    print()

def display_signing_instructions(signing_url: str, message: str, wallet_address: str):
    """Display signing instructions with QR code"""
    
    print(f"{Colors.BOLD}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê{Colors.NC}")
    print(f"{Colors.BOLD}              üì± SCAN QR CODE TO SIGN WITH WALLET{Colors.NC}")
    print(f"{Colors.BOLD}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê{Colors.NC}")
    print()
    
    # Display QR code with signing URL
    display_qr_code(signing_url, "Scan with ANY QR scanner or camera app:")
    
    print(f"{Colors.BOLD}How it works:{Colors.NC}")
    print("  1. Scan QR code above with your phone's camera or QR scanner")
    print("  2. Opens signing page in your browser")
    print("  3. Click 'Connect Wallet & Sign'")
    print("  4. Choose your wallet (MetaMask, Trust, Rainbow, etc.)")
    print("  5. Approve the connection")
    print("  6. Sign the message")
    print("  7. Copy the signature from the page")
    print("  8. Paste it below")
    print()
    
    print(f"{Colors.CYAN}Or open this URL manually:{Colors.NC}")
    print(f"  {signing_url[:80]}")
    if len(signing_url) > 80:
        print(f"  {signing_url[80:160]}")
        if len(signing_url) > 160:
            print(f"  {signing_url[160:]}")
    print()
    
    print(f"{Colors.BOLD}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê{Colors.NC}")
    print()
    
    # Also show the message for reference
    print(f"{Colors.YELLOW}Message being signed (for reference):{Colors.NC}")
    print(f"{Colors.YELLOW}{'‚îÄ'*70}{Colors.NC}")
    print(message)
    print(f"{Colors.YELLOW}{'‚îÄ'*70}{Colors.NC}")
    print()

# =============================================================================
# SIGNATURE VERIFICATION
# =============================================================================

def verify_signature(message: str, signature: str, expected_address: str) -> bool:
    """Verify that signature matches expected address"""
    try:
        # Encode message for EIP-191
        encoded_message = encode_defunct(text=message)
        
        # Recover address from signature
        recovered_address = Account.recover_message(encoded_message, signature=signature)
        
        # Compare (case-insensitive)
        return recovered_address.lower() == expected_address.lower()
    except Exception as e:
        log_error(f"Signature verification failed: {e}")
        return False

# =============================================================================
# REGISTRATION
# =============================================================================

def register_node(orchestrator_url: str, machine_id: str, wallet_address: str, 
                 signature: str, message: str, hardware: Dict[str, Any]) -> Optional[str]:
    """Register node with orchestrator and get API key"""
    try:
        # Build proper HardwareInventory structure
        hardware_inventory = {
            "cpuCores": hardware.get('cores', 0),
            "memoryBytes": hardware.get('memory', 0) * 1024 * 1024 * 1024,  # GB to bytes
            "diskBytes": hardware.get('disk', 0) * 1024 * 1024 * 1024,  # GB to bytes
            "cpuModel": hardware.get('cpu', 'Unknown'),
            "architecture": "x86_64"
        }
        
        # Build complete registration request
        registration_request = {
            "machineId": machine_id,
            "name": hardware.get('hostname', socket.gethostname()),
            "walletAddress": wallet_address,
            "publicIp": get_public_ip(),
            "agentPort": 5100,
            "hardwareInventory": hardware_inventory,
            "agentVersion": "2.3.0-cli",
            "supportedImages": ["ubuntu-22.04", "ubuntu-24.04", "debian-12"],
            "region": "default",
            "zone": "default",
            "signature": signature,
            "message": message,
            "registeredAt": datetime.utcnow().isoformat() + "Z"
        }
        
        response = requests.post(
            f"{orchestrator_url}/api/nodes/register",
            json=registration_request,
            timeout=30
        )
        
        if response.status_code == 200:
            data = response.json()
            if data.get("success"):
                response_data = data.get("data", {})
        
                # Validate required fields
                if not response_data.get("nodeId"):
                    log_error("Node ID not found in response")
                    return None
        
                if not response_data.get("apiKey"):
                    log_error("API key not found in response")
                    return None
        
                return response_data
        
        log_error(f"Registration failed: {response.status_code}")
        if response.text:
            log_error(response.text[:200])
        
        return None
    
    except Exception as e:
        log_error(f"Failed to register node: {e}")
        return None

# =============================================================================
# WEB-BASED AUTHENTICATION FLOW
# =============================================================================

def login_with_web_signing(orchestrator_url: str, wallet_address: str = None, verbose: bool = False):
    """Login using web-based WalletConnect signing"""
    print_banner()
    
    # Get machine_id
    machine_id = get_machine_id()
    
    # Get wallet address if not provided
    if not wallet_address:
        log_info("Enter your Ethereum wallet address:")
        wallet_address = input(f"  {Colors.BOLD}Wallet (0x...):{Colors.NC} ").strip()
        print()
    
    if not wallet_address.startswith('0x') or len(wallet_address) != 42:
        log_error("Invalid wallet address format")
        return False

    # Get hardware info
    hardware = get_hardware_info()
    
    print(f"Machine ID: {machine_id}")
    print(f"Hardware: {hardware['cpu']}")
    
    # Create message WITHOUT node_id
    message = create_signing_message(machine_id, wallet_address, hardware)
    
    # Generate signing URL
    signing_url = generate_signing_url(message, wallet_address, hardware)
    
    # Display instructions with QR code
    display_signing_instructions(signing_url, message, wallet_address)
    
    # Wait for signature
    log_info(f"{Colors.BOLD}After signing on the web page, paste the signature below:{Colors.NC}")
    print()
    
    signature = input(f"  {Colors.BOLD}Signature (0x...):{Colors.NC} ").strip()
    
    if not signature.startswith('0x'):
        log_error("Invalid signature format")
        return False
    
    print()
    log_success("Signature received!")
    
    # Verify signature
    log_info("Verifying signature...")
    if not verify_signature(message, signature, wallet_address):
        log_error("Signature verification failed!")
        log_error("Make sure you signed the exact message shown")
        return False
    
    log_success("Signature verified!")
    print()
    
    # Register with orchestrator
    log_info("Registering with orchestrator...")
    
    response = register_node(
        orchestrator_url=orchestrator_url,
        machine_id=machine_id,
        wallet_address=wallet_address,
        signature=signature,
        message=message,
        hardware=hardware
    )

    if response:
        returned_node_id = response.get('nodeId')
        api_key = response.get('apiKey')
    
        # Verify it matches
        if returned_node_id != node_id:
            log_warn("Using orchestrator's node ID")
            node_id = returned_node_id
    
        save_credentials(node_id, api_key, wallet_address, signature, message)
        
        # Save orchestrator URL to config
        config = load_config()
        config['orchestrator_url'] = orchestrator_url
        save_config(config)
        
        print()
        print(f"{Colors.GREEN}{'‚ïê'*70}{Colors.NC}")
        print(f"{Colors.BOLD}              ‚úÖ Node Authorized Successfully!{Colors.NC}")
        print(f"{Colors.GREEN}{'‚ïê'*70}{Colors.NC}")
        print()
        print(f"  Node ID:      {node_id}")
        print(f"  Wallet:       {wallet_address}")
        print(f"  Credentials:  {CREDENTIALS_FILE}")
        print()
        print("The node agent will start automatically.")
        print("Check status with: systemctl status decloud-node-agent")
        print()
        
        return True
    else:
        log_error("Failed to register node with orchestrator")
        return False

# =============================================================================
# COMMAND HANDLERS
# =============================================================================

def cmd_login(args):
    """Handle login command"""
    # Check if already logged in
    creds = load_credentials()
    if creds and not args.force:
        log_warn("Node already authorized")
        print()
        print(f"  Node ID:  {creds.get('NODE_ID', 'Unknown')}")
        print(f"  Wallet:   {creds.get('WALLET_ADDRESS', 'Unknown')}")
        print(f"  API Key:  {creds.get('API_KEY', 'Unknown')[:20]}...")
        print()
        print("Use --force to re-authorize")
        return
    
    # Get orchestrator URL
    orchestrator_url = args.orchestrator
    if not orchestrator_url:
        config = load_config()
        orchestrator_url = config.get('orchestrator_url', DEFAULT_ORCHESTRATOR_URL)
    
    # Perform login
    success = login_with_web_signing(orchestrator_url, args.wallet)
    sys.exit(0 if success else 1)

def cmd_status(args):
    """Handle status command"""
    print_banner()
    
    creds = load_credentials()
    if not creds:
        log_warn("Node not authorized")
        print()
        print("Run: decloud-node login")
        return
    
    print(f"{Colors.BOLD}Node Status:{Colors.NC}")
    print()
    print(f"  Node ID:       {creds.get('NODE_ID', 'Unknown')}")
    print(f"  Wallet:        {creds.get('WALLET_ADDRESS', 'Unknown')}")
    print(f"  API Key:       {creds.get('API_KEY', 'Unknown')[:20]}...")
    print(f"  Authorized:    {creds.get('AUTHORIZED_AT', 'Unknown')}")
    print()
    
    try:
        result = subprocess.run(
            ['systemctl', 'is-active', 'decloud-node-agent'],
            capture_output=True,
            text=True
        )
        
        if result.stdout.strip() == 'active':
            log_success("Node agent is running")
        else:
            log_warn("Node agent is not running")
            print("Start with: sudo systemctl start decloud-node-agent")
    except:
        log_warn("Could not check service status")

def cmd_logout(args):
    """Handle logout command"""
    print_banner()
    
    creds = load_credentials()
    if not creds:
        log_info("Node not authorized - nothing to do")
        return
    
    log_warn(f"This will remove authorization for node: {creds.get('NODE_ID', 'Unknown')}")
    
    if not args.force:
        response = input("Continue? (y/N): ")
        if response.lower() != 'y':
            log_info("Cancelled")
            return
    
    if os.path.exists(CREDENTIALS_FILE):
        os.remove(CREDENTIALS_FILE)
        log_success("Credentials removed")
    
    try:
        subprocess.run(['systemctl', 'stop', 'decloud-node-agent'], check=False)
        log_success("Node agent stopped")
    except:
        pass
    
    print()
    log_info("Node logged out successfully")
    print("Run 'decloud-node login' to authorize again")

def cmd_version(args):
    """Handle version command"""
    print(f"DeCloud Node CLI v{VERSION} (WalletConnect Web Edition)")

# =============================================================================
# MAIN ENTRY POINT
# =============================================================================

def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description="DeCloud Node CLI - Web-Based WalletConnect Authentication",
        epilog="For support, visit: https://docs.decloud.io"
    )
    
    subparsers = parser.add_subparsers(dest='command', help='Command to execute')
    
    # Login command
    login_parser = subparsers.add_parser('login', help='Login with WalletConnect')
    login_parser.add_argument('--orchestrator', help='Orchestrator URL (optional)')
    login_parser.add_argument('--wallet', help='Wallet address (optional, will prompt if not provided)')
    login_parser.add_argument('--force', action='store_true', help='Force re-authorization')
    login_parser.add_argument('--verbose', action='store_true', help='Verbose output')
    
    # Status command
    status_parser = subparsers.add_parser('status', help='Show node status')
    
    # Logout command
    logout_parser = subparsers.add_parser('logout', help='Logout and remove credentials')
    logout_parser.add_argument('--force', action='store_true', help='Skip confirmation')
    
    # Version command
    version_parser = subparsers.add_parser('version', help='Show version')
    
    args = parser.parse_args()
    
    # Check root for login/logout
    if os.geteuid() != 0 and args.command in ['login', 'logout']:
        log_error("This command must be run as root (use sudo)")
        sys.exit(1)
    
    # Execute command
    if args.command == 'login':
        cmd_login(args)
    elif args.command == 'status':
        cmd_status(args)
    elif args.command == 'logout':
        cmd_logout(args)
    elif args.command == 'version':
        cmd_version(args)
    else:
        parser.print_help()

if __name__ == '__main__':
    main()