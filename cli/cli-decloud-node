#!/usr/bin/env python3
"""
DeCloud Node CLI - Web-Based WalletConnect Authentication

Uses a web page with proper WalletConnect integration for mobile signing.
The QR code contains a URL that opens the signing page on any device.

Usage:
    decloud-node login
    decloud-node status
    decloud-node logout
"""

import sys
import os
import time
import json
import socket
import subprocess
import base64
import urllib.parse
from typing import Optional, Dict, Any
import argparse

# Check dependencies
try:
    import qrcode
    import requests
    from eth_account.messages import encode_defunct
    from eth_account import Account
    from web3 import Web3
except ImportError as e:
    print(f"Error: Missing required package: {e}")
    print("\nPlease install dependencies:")
    print("  pip3 install web3 eth-account requests qrcode pillow")
    sys.exit(1)

# =============================================================================
# CONFIGURATION
# =============================================================================

VERSION = "2.3.0"
DEFAULT_ORCHESTRATOR_URL = "https://decloud.stackfi.tech"

# Signing page URL (you'll host this)
SIGNING_PAGE_URL = "https://decloud.stackfi.tech/sign.html"
# Alternative: Use localhost for testing
# SIGNING_PAGE_URL = "http://localhost:8000/sign.html"

# File paths
CONFIG_DIR = os.path.expanduser("~/.config/decloud")
CONFIG_FILE = os.path.join(CONFIG_DIR, "config.json")
PENDING_AUTH_FILE = os.path.join(CONFIG_DIR, "pending-auth")
CREDENTIALS_FILE = os.path.join(CONFIG_DIR, "credentials")

# =============================================================================
# TERMINAL COLORS
# =============================================================================

class Colors:
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[1;33m'
    BLUE = '\033[0;34m'
    CYAN = '\033[0;36m'
    MAGENTA = '\033[0;35m'
    BOLD = '\033[1m'
    NC = '\033[0m'

# =============================================================================
# LOGGING FUNCTIONS
# =============================================================================

def print_banner():
    """Print CLI banner"""
    print()
    print(f"{Colors.CYAN}{'='*70}{Colors.NC}")
    print(f"{Colors.BOLD}      üîê DeCloud Node Authentication (WalletConnect){Colors.NC}")
    print(f"{Colors.CYAN}{'='*70}{Colors.NC}")
    print()

def log_info(msg):
    print(f"{Colors.BLUE}‚Ñπ{Colors.NC} {msg}")

def log_success(msg):
    print(f"{Colors.GREEN}‚úì{Colors.NC} {msg}")

def log_error(msg):
    print(f"{Colors.RED}‚úó{Colors.NC} {msg}", file=sys.stderr)

def log_warn(msg):
    print(f"{Colors.YELLOW}‚ö†{Colors.NC} {msg}")

# =============================================================================
# SYSTEM INFORMATION FUNCTIONS
# =============================================================================

def get_machine_id() -> str:
    """Get machine ID from /etc/machine-id"""
    try:
        if os.path.exists('/etc/machine-id'):
            with open('/etc/machine-id', 'r') as f:
                machine_id = f.read().strip()
                if machine_id:
                    return machine_id
        
        log_error("Could not read /etc/machine-id")
        sys.exit(1)
    except Exception as e:
        log_error(f"Failed to get machine ID: {e}")
        sys.exit(1)

# =============================================================================
# CONFIGURATION MANAGEMENT
# =============================================================================

def load_credentials() -> Optional[Dict[str, str]]:
    """Load saved credentials"""
    if not os.path.exists(CREDENTIALS_FILE):
        return None
    
    credentials = {}
    with open(CREDENTIALS_FILE, 'r') as f:
        for line in f:
            if '=' in line:
                key, value = line.strip().split('=', 1)
                credentials[key] = value
    
    return credentials if credentials else None

# =============================================================================
# SIGNING URL GENERATION
# =============================================================================

def create_signing_message(machine_id: str, wallet_address: str) -> str:
    """Create message to be signed (NO node_id needed!)"""
    timestamp = int(time.time())
    hostname = socket.gethostname()
    
    message = f"""Sign this message to authorize your DeCloud node:

Machine ID: {machine_id}
Wallet: {wallet_address}
Hostname: {hostname}
Timestamp: {timestamp}

This signature proves you own this wallet and authorizes the node to operate on your behalf.

NO FUNDS WILL BE TRANSFERRED - This is only for node authorization."""
    
    return message

def generate_signing_url(message: str, wallet_address: str) -> str:
    """
    Generate URL to signing page with parameters
    
    Format: https://decloud.stackfi.tech/sign.html?message=base64&wallet=0x...
    """
    # Encode message to base64 for URL
    message_b64 = base64.b64encode(message.encode()).decode()
    
    # Build URL parameters
    params = {
        'message': message_b64,
        'wallet': wallet_address
    }
    
    # Create full URL
    url = f"{SIGNING_PAGE_URL}?{urllib.parse.urlencode(params)}"
    
    return url

def display_qr_code(data: str, title: str = "Scan to sign"):
    """Display QR code in terminal"""
    qr = qrcode.QRCode(
        version=1,
        error_correction=qrcode.constants.ERROR_CORRECT_L,
        box_size=1,
        border=2,
    )
    qr.add_data(data)
    qr.make(fit=True)
    
    print()
    print(f"{Colors.BOLD}{Colors.CYAN}{title}{Colors.NC}")
    print()
    qr.print_ascii(invert=True)
    print()

def display_signing_instructions(signing_url: str, message: str, wallet_address: str):
    """Display signing instructions with QR code"""
    
    print(f"{Colors.BOLD}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê{Colors.NC}")
    print(f"{Colors.BOLD}              üì± SCAN QR CODE TO SIGN WITH WALLET{Colors.NC}")
    print(f"{Colors.BOLD}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê{Colors.NC}")
    print()
    
    # Display QR code with signing URL
    display_qr_code(signing_url, "Scan with ANY QR scanner or camera app:")
    
    print(f"{Colors.BOLD}How it works:{Colors.NC}")
    print("  1. Scan QR code with your phone's camera")
    print("  2. Opens signing page in your browser")
    print("  3. Connect your wallet and sign the message")
    print("  4. Copy the signature")
    print("  5. Paste it below")
    print()
    
    print(f"{Colors.CYAN}Or open this URL manually:{Colors.NC}")
    print(f"  {signing_url[:80]}")
    if len(signing_url) > 80:
        print(f"  {signing_url[80:160]}")
        if len(signing_url) > 160:
            print(f"  {signing_url[160:]}")
    print()
    
    print(f"{Colors.BOLD}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê{Colors.NC}")
    print()
    
    # Also show the message for reference
    print(f"{Colors.YELLOW}Message being signed (for reference):{Colors.NC}")
    print(f"{Colors.YELLOW}{'‚îÄ'*70}{Colors.NC}")
    print(message)
    print(f"{Colors.YELLOW}{'‚îÄ'*70}{Colors.NC}")
    print()

# =============================================================================
# SIGNATURE VERIFICATION
# =============================================================================

def verify_signature(message: str, signature: str, expected_address: str) -> bool:
    """Verify that signature matches expected address"""
    try:
        # Encode message for EIP-191
        encoded_message = encode_defunct(text=message)
        
        # Recover address from signature
        recovered_address = Account.recover_message(encoded_message, signature=signature)
        
        # Compare (case-insensitive)
        return recovered_address.lower() == expected_address.lower()
    except Exception as e:
        log_error(f"Signature verification failed: {e}")
        return False

def save_pending_auth(auth_data: Dict[str, Any]):
    """Save pending authentication for node agent to process"""
    os.makedirs(os.path.dirname(PENDING_AUTH_FILE), exist_ok=True)
    
    with open(PENDING_AUTH_FILE, 'w') as f:
        json.dump(auth_data, f, indent=2)
    
    os.chmod(PENDING_AUTH_FILE, 0o600)
    log_success(f"Authentication saved to {PENDING_AUTH_FILE}")

# =============================================================================
# WEB-BASED AUTHENTICATION FLOW
# =============================================================================

def login_with_web_signing(orchestrator_url: str, wallet_address: str = None, force: bool = False, verbose: bool = False):
    """Login using web-based WalletConnect signing"""
    print_banner()
    
    # Check if already authenticated
    if os.path.exists(PENDING_AUTH_FILE) and not force:
        log_warn("Pending authentication already exists")
        print("Use --force to overwrite")
        return

    # Get machine_id
    machine_id = get_machine_id()
    
    # Get wallet address if not provided
    if not wallet_address:
        log_info("Enter your Ethereum wallet address:")
        wallet_address = input(f"  {Colors.BOLD}Wallet (0x...):{Colors.NC} ").strip()
        print()
    
    if not wallet_address.startswith('0x') or len(wallet_address) != 42:
        log_error("Invalid wallet address format")
        return False

    print(f"Machine ID: {machine_id}")
    
    # Create message
    message = create_signing_message(machine_id, wallet_address)
    
    # Generate signing URL
    signing_url = generate_signing_url(message, wallet_address)
    
    # Display instructions with QR code
    display_signing_instructions(signing_url, message, wallet_address)
    
    # Wait for signature
    log_info(f"{Colors.BOLD}After signing on the web page, paste the signature below:{Colors.NC}")
    print()
    
    signature = input(f"  {Colors.BOLD}Signature (0x...):{Colors.NC} ").strip()
    
    if not signature.startswith('0x'):
        log_error("Invalid signature format")
        return False
    
    print()
    log_success("Signature received!")
    
    # Verify signature
    log_info("Verifying signature...")
    if not verify_signature(message, signature, wallet_address):
        log_error("Signature verification failed!")
        log_error("Make sure you signed the exact message shown")
        return False
    
    log_success("Signature verified!")

    # Save pending authentication
    auth_data = {
        "walletAddress": wallet_address,
        "signature": signature,
        "message": message,
        "timestamp": int(time.time()),
        "machineId": machine_id
    }
    
    save_pending_auth(auth_data)

    print()
    print(f"{Colors.GREEN}{'‚ïê'*70}{Colors.NC}")
    print(f"{Colors.BOLD}              ‚úÖ Authentication Saved!{Colors.NC}")
    print(f"{Colors.GREEN}{'‚ïê'*70}{Colors.NC}")
    print()
    print("Node agent will complete registration automatically.")
    print()
    print("Check status:")
    print("  sudo journalctl -u decloud-node-agent -f")
    print()

# =============================================================================
# COMMAND HANDLERS
# =============================================================================

def cmd_login(args):
    """Handle login command"""
    # Check if already logged in
    creds = load_credentials()
    if creds and not args.force:
        log_warn("Node already authorized")
        print()
        print(f"  Node ID:  {creds.get('NODE_ID', 'Unknown')}")
        print(f"  Wallet:   {creds.get('WALLET_ADDRESS', 'Unknown')}")
        print(f"  API Key:  {creds.get('API_KEY', 'Unknown')[:20]}...")
        print()
        print("Use --force to re-authorize")
        return
    
    # Get orchestrator URL
    orchestrator_url = args.orchestrator
    
    # Perform login
    success = login_with_web_signing(orchestrator_url, args.wallet, args.force)
    sys.exit(0 if success else 1)

def cmd_status(args):
    """Handle status command"""
    print_banner()
    
    creds = load_credentials()
    if not creds:
        log_warn("Node not authorized")
        print()
        print("Run: decloud-node login")
        return
    
    print(f"{Colors.BOLD}Node Status:{Colors.NC}")
    print()
    print(f"  Node ID:       {creds.get('NODE_ID', 'Unknown')}")
    print(f"  Wallet:        {creds.get('WALLET_ADDRESS', 'Unknown')}")
    print(f"  API Key:       {creds.get('API_KEY', 'Unknown')[:20]}...")
    print(f"  Authorized:    {creds.get('AUTHORIZED_AT', 'Unknown')}")
    print()
    
    try:
        result = subprocess.run(
            ['systemctl', 'is-active', 'decloud-node-agent'],
            capture_output=True,
            text=True
        )
        
        if result.stdout.strip() == 'active':
            log_success("Node agent is running")
        else:
            log_warn("Node agent is not running")
            print("Start with: sudo systemctl start decloud-node-agent")
    except:
        log_warn("Could not check service status")

def cmd_logout(args):
    """Handle logout command"""
    print_banner()
    
    creds = load_credentials()
    if not creds:
        log_info("Node not authorized - nothing to do")
        return
    
    log_warn(f"This will remove authorization for node: {creds.get('NODE_ID', 'Unknown')}")
    
    if not args.force:
        response = input("Continue? (y/N): ")
        if response.lower() != 'y':
            log_info("Cancelled")
            return
    
    if os.path.exists(CREDENTIALS_FILE):
        os.remove(CREDENTIALS_FILE)
        log_success("Credentials removed")
    
    try:
        subprocess.run(['systemctl', 'stop', 'decloud-node-agent'], check=False)
        log_success("Node agent stopped")
    except:
        pass
    
    print()
    log_info("Node logged out successfully")
    print("Run 'decloud-node login' to authorize again")

def cmd_version(args):
    """Handle version command"""
    print(f"DeCloud Node CLI v{VERSION} (WalletConnect Web Edition)")

# =============================================================================
# MAIN ENTRY POINT
# =============================================================================

def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description="DeCloud Node CLI - Web-Based WalletConnect Authentication",
        epilog="For support, visit: https://docs.decloud.io"
    )
    
    subparsers = parser.add_subparsers(dest='command', help='Command to execute')
    
    # Login command
    login_parser = subparsers.add_parser('login', help='Login with WalletConnect')
    login_parser.add_argument('--orchestrator', help='Orchestrator URL (optional)')
    login_parser.add_argument('--wallet', help='Wallet address (optional, will prompt if not provided)')
    login_parser.add_argument('--force', action='store_true', help='Force re-authorization')
    login_parser.add_argument('--verbose', action='store_true', help='Verbose output')
    
    # Status command
    status_parser = subparsers.add_parser('status', help='Show node status')
    
    # Logout command
    logout_parser = subparsers.add_parser('logout', help='Logout and remove credentials')
    logout_parser.add_argument('--force', action='store_true', help='Skip confirmation')
    
    # Version command
    version_parser = subparsers.add_parser('version', help='Show version')
    
    args = parser.parse_args()
    
    # Check root for login/logout
    if os.geteuid() != 0 and args.command in ['login', 'logout']:
        log_error("This command must be run as root (use sudo)")
        sys.exit(1)
    
    # Execute command
    if args.command == 'login':
        cmd_login(args)
    elif args.command == 'status':
        cmd_status(args)
    elif args.command == 'logout':
        cmd_logout(args)
    elif args.command == 'version':
        cmd_version(args)
    else:
        parser.print_help()

if __name__ == '__main__':
    main()