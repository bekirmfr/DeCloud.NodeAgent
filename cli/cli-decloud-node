#!/usr/bin/env python3
"""
DeCloud Node CLI - WalletConnect Authentication

This CLI is automatically installed by the DeCloud node agent installer.
It enables node operators to authenticate using their mobile wallet via WalletConnect.

Usage:
    decloud-node login
    decloud-node status
    decloud-node logout
    
The WalletConnect Project ID is pre-configured and managed by DeCloud.
"""

import sys
import os
import time
import json
import hashlib
import socket
from datetime import datetime
from typing import Optional, Dict, Any
import argparse

# Check dependencies
try:
    import qrcode
    import requests
    from eth_account.messages import encode_defunct
    from web3 import Web3
    from walletconnect import WalletConnectClient
except ImportError as e:
    print(f"Error: Missing required package: {e}")
    print("\nThis should not happen if installed via install.sh")
    print("If you see this error, please report it to DeCloud support.")
    sys.exit(1)

# =============================================================================
# CONFIGURATION - Managed by DeCloud
# =============================================================================

VERSION = "2.1.0"

# WalletConnect Project ID (managed by DeCloud orchestrator)
# This is a shared Project ID for all DeCloud nodes
WALLETCONNECT_PROJECT_ID = "708cede4d366aa77aead71dbc67d8ae5"

# Default orchestrator URL (can be overridden with --orchestrator)
DEFAULT_ORCHESTRATOR_URL = "https://decloud.stackfi.tech"

# File paths
CREDENTIALS_FILE = "/etc/decloud/credentials"
CONFIG_FILE = "/etc/decloud/config.json"

# =============================================================================
# TERMINAL COLORS
# =============================================================================

class Colors:
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[1;33m'
    BLUE = '\033[0;34m'
    CYAN = '\033[0;36m'
    BOLD = '\033[1m'
    NC = '\033[0m'

# =============================================================================
# LOGGING FUNCTIONS
# =============================================================================

def print_banner():
    """Print CLI banner"""
    print()
    print(f"{Colors.CYAN}{'='*60}{Colors.NC}")
    print(f"{Colors.BOLD}    ðŸ” DeCloud Node Authentication{Colors.NC}")
    print(f"{Colors.CYAN}{'='*60}{Colors.NC}")
    print()

def log_info(msg):
    print(f"{Colors.BLUE}â„¹{Colors.NC} {msg}")

def log_success(msg):
    print(f"{Colors.GREEN}âœ“{Colors.NC} {msg}")

def log_error(msg):
    print(f"{Colors.RED}âœ—{Colors.NC} {msg}", file=sys.stderr)

def log_warn(msg):
    print(f"{Colors.YELLOW}âš {Colors.NC} {msg}")

# =============================================================================
# SYSTEM INFORMATION FUNCTIONS
# =============================================================================

def get_node_id() -> str:
    """Generate deterministic node ID based on hardware"""
    try:
        # Get CPU info
        cpu_info = ""
        if os.path.exists('/proc/cpuinfo'):
            with open('/proc/cpuinfo', 'r') as f:
                cpu_info = f.read()
        
        # Get machine ID
        machine_id = ""
        if os.path.exists('/etc/machine-id'):
            with open('/etc/machine-id', 'r') as f:
                machine_id = f.read().strip()
        
        # Get hostname
        hostname = socket.gethostname()
        
        # Create hash
        data = f"{cpu_info}{machine_id}{hostname}"
        node_hash = hashlib.sha256(data.encode()).hexdigest()[:16]
        
        return f"node-{hostname}-{node_hash}"
    except Exception as e:
        log_error(f"Failed to generate node ID: {e}")
        sys.exit(1)

def get_hardware_info() -> Dict[str, Any]:
    """Get hardware information"""
    import subprocess
    
    def run_cmd(cmd):
        try:
            return subprocess.check_output(cmd, shell=True, text=True).strip()
        except:
            return "Unknown"
    
    cpu_model = run_cmd("lscpu | grep 'Model name' | cut -d':' -f2 | xargs")
    cpu_cores = run_cmd("nproc")
    memory_gb = run_cmd("free -g | awk '/^Mem:/{print $2}'")
    disk_gb = run_cmd("df -BG / | awk 'NR==2{print $2}' | tr -d 'G'")
    
    return {
        "cpu": cpu_model or "Unknown CPU",
        "cores": int(cpu_cores) if cpu_cores.isdigit() else 0,
        "memory": int(memory_gb) if memory_gb.isdigit() else 0,
        "disk": int(disk_gb) if disk_gb.isdigit() else 0,
        "hostname": socket.gethostname()
    }

def get_public_ip() -> str:
    """Get public IP address"""
    try:
        response = requests.get('https://api.ipify.org', timeout=5)
        return response.text.strip()
    except:
        return "Unknown"

# =============================================================================
# CONFIGURATION MANAGEMENT
# =============================================================================

def load_config() -> Dict[str, Any]:
    """Load configuration from file"""
    if os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, 'r') as f:
            return json.load(f)
    return {}

def save_config(config: Dict[str, Any]):
    """Save configuration to file"""
    os.makedirs(os.path.dirname(CONFIG_FILE), exist_ok=True)
    with open(CONFIG_FILE, 'w') as f:
        json.dump(config, f, indent=2)
    os.chmod(CONFIG_FILE, 0o600)

def load_credentials() -> Optional[Dict[str, str]]:
    """Load saved credentials"""
    if not os.path.exists(CREDENTIALS_FILE):
        return None
    
    credentials = {}
    with open(CREDENTIALS_FILE, 'r') as f:
        for line in f:
            if '=' in line:
                key, value = line.strip().split('=', 1)
                credentials[key] = value
    
    return credentials if credentials else None

def save_credentials(node_id: str, api_key: str, wallet_address: str):
    """Save credentials to file"""
    os.makedirs(os.path.dirname(CREDENTIALS_FILE), exist_ok=True)
    
    with open(CREDENTIALS_FILE, 'w') as f:
        f.write(f"NODE_ID={node_id}\n")
        f.write(f"API_KEY={api_key}\n")
        f.write(f"WALLET_ADDRESS={wallet_address}\n")
        f.write(f"AUTHORIZED_AT={datetime.utcnow().isoformat()}\n")
    
    os.chmod(CREDENTIALS_FILE, 0o600)
    log_success(f"Credentials saved to {CREDENTIALS_FILE}")

# =============================================================================
# WALLETCONNECT FUNCTIONS
# =============================================================================

def display_qr_code(uri: str):
    """Display QR code in terminal"""
    qr = qrcode.QRCode()
    qr.add_data(uri)
    qr.make()
    
    print()
    print("Scan this QR code with your mobile wallet:")
    print("(MetaMask, Trust Wallet, Rainbow, Coinbase Wallet, etc.)")
    print()
    qr.print_ascii(invert=True)
    print()

def register_node(orchestrator_url: str, node_id: str, wallet_address: str, 
                 signature: str, message: str, hardware: Dict[str, Any]) -> Optional[str]:
    """Register node with orchestrator and get API key"""
    try:
        response = requests.post(
            f"{orchestrator_url}/api/nodes/register",
            json={
                "nodeId": node_id,
                "walletAddress": wallet_address,
                "signature": signature,
                "message": message,
                "hardwareInfo": hardware,
                "publicIp": get_public_ip()
            },
            timeout=30
        )
        
        if response.status_code == 200:
            data = response.json()
            if data.get("success"):
                return data["data"]["apiKey"]
        
        log_error(f"Registration failed: {response.status_code}")
        if response.text:
            log_error(response.text[:200])
        
        return None
    
    except Exception as e:
        log_error(f"Failed to register node: {e}")
        return None

def login_walletconnect(orchestrator_url: str, verbose: bool = False):
    """Login using WalletConnect"""
    print_banner()
    
    # Get node information
    node_id = get_node_id()
    hardware = get_hardware_info()
    
    log_info(f"Node ID: {node_id}")
    log_info(f"Hardware: {hardware['cpu']}")
    log_info(f"Resources: {hardware['cores']} cores / {hardware['memory']}GB RAM / {hardware['disk']}GB disk")
    print()
    
    try:
        # Initialize WalletConnect client
        log_info("Initializing WalletConnect...")
        
        wc = WalletConnectClient(
            project_id=WALLETCONNECT_PROJECT_ID,
            metadata={
                "name": "DeCloud Node",
                "description": "Authorize your DeCloud compute node",
                "url": "https://decloud.io",
                "icons": ["https://decloud.io/icon.png"]
            }
        )
        
        # Create session
        session = wc.create_session()
        uri = session.uri
        
        # Display QR code
        display_qr_code(uri)
        
        log_info(f"Or use this link on your mobile device:")
        print(f"  {uri}")
        print()
        
        # Wait for wallet connection
        log_info("Waiting for wallet connection...")
        
        accounts = wc.wait_for_session_approval(timeout=120)
        
        if not accounts or len(accounts) == 0:
            log_error("No wallet connected")
            return False
        
        wallet_address = accounts[0]
        log_success(f"Wallet connected: {wallet_address}")
        print()
        
        # Create authorization message
        timestamp = int(time.time())
        message = f"""Sign this message to authorize your DeCloud node:

Node ID: {node_id}
Wallet: {wallet_address}
Hardware: {hardware['cpu']}
Resources: {hardware['cores']} cores / {hardware['memory']}GB RAM
Timestamp: {timestamp}

This signature proves you own this wallet and authorizes the node to operate on your behalf.

NO FUNDS WILL BE TRANSFERRED - This is only for node authorization."""
        
        log_info("ðŸ“± Please sign the message on your phone...")
        
        # Request signature via WalletConnect
        signature = wc.sign_message(
            account=wallet_address,
            message=message
        )
        
        log_success("Signature received!")
        print()
        
        # Disconnect WalletConnect
        wc.disconnect()
        
        # Register with orchestrator
        log_info("Registering with orchestrator...")
        
        api_key = register_node(
            orchestrator_url=orchestrator_url,
            node_id=node_id,
            wallet_address=wallet_address,
            signature=signature,
            message=message,
            hardware=hardware
        )
        
        if api_key:
            # Save credentials
            save_credentials(node_id, api_key, wallet_address)
            
            # Save orchestrator URL to config
            config = load_config()
            config['orchestrator_url'] = orchestrator_url
            save_config(config)
            
            print()
            print(f"{Colors.GREEN}{'='*60}{Colors.NC}")
            print(f"{Colors.BOLD}    âœ… Node Authorized Successfully!{Colors.NC}")
            print(f"{Colors.GREEN}{'='*60}{Colors.NC}")
            print()
            print(f"  Node ID:      {node_id}")
            print(f"  Wallet:       {wallet_address}")
            print(f"  Credentials:  {CREDENTIALS_FILE}")
            print()
            print("The node agent will start automatically.")
            print("Check status with: systemctl status decloud-node-agent")
            print()
            
            return True
        else:
            log_error("Failed to register node with orchestrator")
            return False
    
    except TimeoutError:
        log_error("Connection timeout - please try again")
        return False
    except KeyboardInterrupt:
        print()
        log_warn("Login cancelled by user")
        return False
    except Exception as e:
        log_error(f"Login failed: {e}")
        if verbose:
            import traceback
            traceback.print_exc()
        return False

# =============================================================================
# COMMAND HANDLERS
# =============================================================================

def cmd_login(args):
    """Handle login command"""
    # Check if already logged in
    creds = load_credentials()
    if creds and not args.force:
        log_warn("Node already authorized")
        print()
        print(f"  Node ID:  {creds.get('NODE_ID', 'Unknown')}")
        print(f"  Wallet:   {creds.get('WALLET_ADDRESS', 'Unknown')}")
        print(f"  API Key:  {creds.get('API_KEY', 'Unknown')[:20]}...")
        print()
        print("Use --force to re-authorize")
        return
    
    # Get orchestrator URL
    orchestrator_url = args.orchestrator
    if not orchestrator_url:
        config = load_config()
        orchestrator_url = config.get('orchestrator_url', DEFAULT_ORCHESTRATOR_URL)
    
    # Perform login
    success = login_walletconnect(orchestrator_url, args.verbose)
    sys.exit(0 if success else 1)

def cmd_status(args):
    """Handle status command"""
    print_banner()
    
    # Check credentials
    creds = load_credentials()
    if not creds:
        log_warn("Node not authorized")
        print()
        print("Run: decloud-node login")
        return
    
    # Display status
    print(f"{Colors.BOLD}Node Status:{Colors.NC}")
    print()
    print(f"  Node ID:       {creds.get('NODE_ID', 'Unknown')}")
    print(f"  Wallet:        {creds.get('WALLET_ADDRESS', 'Unknown')}")
    print(f"  API Key:       {creds.get('API_KEY', 'Unknown')[:20]}...")
    print(f"  Authorized:    {creds.get('AUTHORIZED_AT', 'Unknown')}")
    print()
    
    # Check service status
    import subprocess
    try:
        result = subprocess.run(
            ['systemctl', 'is-active', 'decloud-node-agent'],
            capture_output=True,
            text=True
        )
        
        if result.stdout.strip() == 'active':
            log_success("Node agent is running")
        else:
            log_warn("Node agent is not running")
            print("Start with: sudo systemctl start decloud-node-agent")
    except:
        log_warn("Could not check service status")

def cmd_logout(args):
    """Handle logout command"""
    print_banner()
    
    creds = load_credentials()
    if not creds:
        log_info("Node not authorized - nothing to do")
        return
    
    log_warn(f"This will remove authorization for node: {creds.get('NODE_ID', 'Unknown')}")
    
    if not args.force:
        response = input("Continue? (y/N): ")
        if response.lower() != 'y':
            log_info("Cancelled")
            return
    
    # Remove credentials
    if os.path.exists(CREDENTIALS_FILE):
        os.remove(CREDENTIALS_FILE)
        log_success("Credentials removed")
    
    # Stop service
    import subprocess
    try:
        subprocess.run(['systemctl', 'stop', 'decloud-node-agent'], check=False)
        log_success("Node agent stopped")
    except:
        pass
    
    print()
    log_info("Node logged out successfully")
    print("Run 'decloud-node login' to authorize again")

def cmd_version(args):
    """Handle version command"""
    print(f"DeCloud Node CLI v{VERSION}")
    print(f"WalletConnect Project ID: {WALLETCONNECT_PROJECT_ID[:20]}...")

# =============================================================================
# MAIN ENTRY POINT
# =============================================================================

def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description="DeCloud Node CLI - WalletConnect Authentication",
        epilog="For support, visit: https://docs.decloud.io"
    )
    
    subparsers = parser.add_subparsers(dest='command', help='Command to execute')
    
    # Login command
    login_parser = subparsers.add_parser('login', help='Login with WalletConnect')
    login_parser.add_argument('--orchestrator', help='Orchestrator URL (optional)')
    login_parser.add_argument('--force', action='store_true', help='Force re-authorization')
    login_parser.add_argument('--verbose', action='store_true', help='Verbose output')
    
    # Status command
    status_parser = subparsers.add_parser('status', help='Show node status')
    
    # Logout command
    logout_parser = subparsers.add_parser('logout', help='Logout and remove credentials')
    logout_parser.add_argument('--force', action='store_true', help='Skip confirmation')
    
    # Version command
    version_parser = subparsers.add_parser('version', help='Show version')
    
    args = parser.parse_args()
    
    # Check root for login/logout
    if os.geteuid() != 0 and args.command in ['login', 'logout']:
        log_error("This command must be run as root (use sudo)")
        sys.exit(1)
    
    # Execute command
    if args.command == 'login':
        cmd_login(args)
    elif args.command == 'status':
        cmd_status(args)
    elif args.command == 'logout':
        cmd_logout(args)
    elif args.command == 'version':
        cmd_version(args)
    else:
        parser.print_help()

if __name__ == '__main__':
    main()
