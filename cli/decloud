#!/usr/bin/env bash

#═══════════════════════════════════════════════════════════════════════════
# DeCloud Node Agent CLI
# Version: 1.0.0
#
# A unified CLI tool for managing DeCloud node agent operations
# Inspired by: docker, kubectl, systemctl
#
# Usage:
#   decloud <command> [options]
#   decloud --help
#═══════════════════════════════════════════════════════════════════════════

set -euo pipefail

# ============================================================================
# GLOBAL CONSTANTS
# ============================================================================

readonly VERSION="1.1.0"
readonly SCRIPT_NAME="$(basename "$0")"
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Configuration paths
readonly CONFIG_DIR="/etc/decloud"
readonly CREDENTIALS_FILE="$CONFIG_DIR/credentials"
readonly PENDING_AUTH_FILE="$CONFIG_DIR/pending-auth"
readonly VM_STORAGE_PATH="/var/lib/decloud/vms"
readonly BACKUP_PATH="/var/backups/decloud"
readonly LOG_DIR="/var/log/decloud"

# Service name
readonly SERVICE_NAME="decloud-node-agent"

# Node agent API
readonly NODE_AGENT_URL="http://localhost:5100"

# Colors
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly CYAN='\033[0;36m'
readonly BOLD='\033[1m'
readonly NC='\033[0m' # No Color

# Exit codes
readonly EXIT_SUCCESS=0
readonly EXIT_ERROR=1
readonly EXIT_USAGE=2
readonly EXIT_NO_AUTH=3
readonly EXIT_API_ERROR=4

# ============================================================================
# LOGGING FUNCTIONS
# ============================================================================

log_info() {
    echo -e "${BLUE}[INFO]${NC} $*"
}

log_success() {
    echo -e "${GREEN}[✓]${NC} $*"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $*" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

log_debug() {
    if [[ "${DEBUG:-0}" == "1" ]]; then
        echo -e "${CYAN}[DEBUG]${NC} $*" >&2
    fi
}

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

check_root() {
    if [[ $EUID -ne 0 ]]; then
        log_error "This command requires root privileges"
        log_info "Please run with sudo: sudo $SCRIPT_NAME $*"
        exit $EXIT_ERROR
    fi
}

check_not_root() {
    if [[ $EUID -eq 0 ]]; then
        log_error "This command should not be run as root"
        exit $EXIT_ERROR
    fi
}

check_dependencies() {
    local missing_deps=()
    
    for cmd in "$@"; do
        if ! command -v "$cmd" &>/dev/null; then
            missing_deps+=("$cmd")
        fi
    done
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        log_error "Missing required dependencies: ${missing_deps[*]}"
        return 1
    fi
    
    return 0
}

check_service_running() {
    if ! systemctl is-active --quiet "$SERVICE_NAME"; then
        log_warn "Node agent service is not running"
        return 1
    fi
    return 0
}

check_authenticated() {
    if [[ ! -f "$CREDENTIALS_FILE" ]]; then
        log_error "Node not authenticated"
        log_info "Run: $SCRIPT_NAME login"
        exit $EXIT_NO_AUTH
    fi
}

get_node_id() {
    if [[ -f "$CREDENTIALS_FILE" ]]; then
        grep "^NODE_ID=" "$CREDENTIALS_FILE" | cut -d= -f2 || echo ""
    else
        echo ""
    fi
}

get_machine_id() {
    if [[ -f /etc/machine-id ]]; then
        cat /etc/machine-id
    else
        log_error "Cannot read /etc/machine-id"
        exit $EXIT_ERROR
    fi
}

# ============================================================================
# API FUNCTIONS
# ============================================================================

api_call() {
    local method="$1"
    local endpoint="$2"
    local data="${3:-}"
    
    local url="${NODE_AGENT_URL}${endpoint}"
    local response
    local http_code
    
    log_debug "API $method $url"
    
    if [[ -n "$data" ]]; then
        response=$(curl -s -w "\n%{http_code}" -X "$method" \
            -H "Content-Type: application/json" \
            -d "$data" \
            "$url" 2>&1)
    else
        response=$(curl -s -w "\n%{http_code}" -X "$method" "$url" 2>&1)
    fi
    
    http_code=$(echo "$response" | tail -n1)
    response=$(echo "$response" | sed '$d')
    
    log_debug "HTTP $http_code: $response"
    
    if [[ "$http_code" -ge 200 && "$http_code" -lt 300 ]]; then
        echo "$response"
        return 0
    else
        log_error "API error (HTTP $http_code): $response"
        return 1
    fi
}

api_get() {
    api_call "GET" "$1"
}

api_post() {
    api_call "POST" "$1" "$2"
}

api_delete() {
    api_call "DELETE" "$1"
}

# ============================================================================
# AUTHENTICATION COMMANDS
# ============================================================================

cmd_login() {
    check_root
    
    log_info "Starting node authentication..."
    
    if ! command -v cli-decloud-node &>/dev/null; then
        log_error "Authentication CLI not found"
        log_info "Please install the DeCloud node agent first"
        exit $EXIT_ERROR
    fi
    
    # Delegate to Python CLI for wallet authentication
    exec cli-decloud-node login "$@"
}

cmd_logout() {
    check_root
    
    log_info "Logging out node..."
    
    if ! command -v cli-decloud-node &>/dev/null; then
        log_error "Authentication CLI not found"
        exit $EXIT_ERROR
    fi
    
    # Delegate to Python CLI
    exec cli-decloud-node logout "$@"
}

# ============================================================================
# STATUS & INFO COMMANDS
# ============================================================================

cmd_status() {
    echo ""
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}  DeCloud Node Agent Status${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo ""
    
    # Authentication status
    echo -e "${BOLD}Authentication:${NC}"
    if [[ -f "$CREDENTIALS_FILE" ]]; then
        local node_id=$(get_node_id)
        local wallet=$(grep "^WALLET_ADDRESS=" "$CREDENTIALS_FILE" | cut -d= -f2 || echo "Unknown")
        local api_key=$(grep "^API_KEY=" "$CREDENTIALS_FILE" | cut -d= -f2 || echo "Unknown")
        
        log_success "Authenticated"
        echo "  Node ID:  $node_id"
        echo "  Wallet:   $wallet"
        echo "  API Key:  ${api_key:0:20}..."
    else
        log_warn "Not authenticated"
        echo "  Run: $SCRIPT_NAME login"
    fi
    echo ""
    
    # Service status
    echo -e "${BOLD}Service:${NC}"
    if systemctl is-active --quiet "$SERVICE_NAME"; then
        log_success "Running"
        
        # Uptime
        local uptime=$(systemctl show -p ActiveEnterTimestamp "$SERVICE_NAME" | cut -d= -f2)
        if [[ -n "$uptime" ]]; then
            echo "  Started:  $uptime"
        fi
        
        # Memory usage
        local memory=$(systemctl show -p MemoryCurrent "$SERVICE_NAME" | cut -d= -f2)
        if [[ -n "$memory" && "$memory" != "[not set]" ]]; then
            local memory_mb=$((memory / 1024 / 1024))
            echo "  Memory:   ${memory_mb}MB"
        fi
    else
        log_warn "Not running"
        echo "  Start with: sudo systemctl start $SERVICE_NAME"
    fi
    echo ""
    
    # Health check
    echo -e "${BOLD}Health:${NC}"
    if check_service_running; then
        if health=$(api_get "/api/node/health" 2>/dev/null); then
            log_success "API responding"
            echo "$health" | jq -r '  .status' 2>/dev/null || echo "$health"
        else
            log_warn "API not responding"
        fi
    else
        log_warn "Service not running"
    fi
    echo ""
    
    # VM count
    echo -e "${BOLD}Virtual Machines:${NC}"
    if [[ -f "$CREDENTIALS_FILE" ]] && check_service_running; then
        if vms=$(api_get "/api/vms" 2>/dev/null); then
            local total=$(echo "$vms" | jq -r 'length' 2>/dev/null || echo "0")
            local running=$(echo "$vms" | jq -r '[.[] | select(.state == 3)] | length' 2>/dev/null || echo "0")
            echo "  Total:    $total"
            echo "  Running:  $running"
        else
            echo "  Unable to fetch VM data"
        fi
    else
        echo "  Not available (not authenticated or service not running)"
    fi
    echo ""
    
    # Network status
    echo -e "${BOLD}Network:${NC}"
    if check_service_running && [[ -f "$CREDENTIALS_FILE" ]]; then
        if status=$(api_get "/api/node/network/status" 2>/dev/null); then
            local internet=$(echo "$status" | jq -r '.isInternetReachable // "unknown"' 2>/dev/null)
            local orchestrator=$(echo "$status" | jq -r '.isOrchestratorReachable // "unknown"' 2>/dev/null)
            
            if [[ "$internet" == "true" ]]; then
                log_success "Internet reachable"
            else
                log_warn "Internet unreachable"
            fi
            
            if [[ "$orchestrator" == "true" ]]; then
                log_success "Orchestrator reachable"
            else
                log_warn "Orchestrator unreachable"
            fi
        fi
    else
        echo "  Not available"
    fi
    echo ""
}

cmd_info() {
    check_authenticated
    
    echo ""
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}  Node Information${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo ""
    
    if ! check_service_running; then
        log_error "Service not running"
        exit $EXIT_ERROR
    fi
    
    # Get detailed node info from API
    if node_info=$(api_get "/api/node" 2>/dev/null); then
        echo "$node_info" | jq -C '.' || echo "$node_info"
    else
        log_error "Failed to fetch node information"
        exit $EXIT_API_ERROR
    fi
    
    echo ""
}

cmd_resources() {
    check_authenticated
    
    echo ""
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}  Resource Information${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo ""
    
    if ! check_service_running; then
        log_error "Service not running"
        exit $EXIT_ERROR
    fi
    
    # CPU
    echo -e "${BOLD}CPU:${NC}"
    if cpu=$(api_get "/api/node/cpu" 2>/dev/null); then
        echo "$cpu" | jq -C '.' || echo "$cpu"
    fi
    echo ""
    
    # Memory
    echo -e "${BOLD}Memory:${NC}"
    if memory=$(api_get "/api/node/memory" 2>/dev/null); then
        echo "$memory" | jq -C '.' || echo "$memory"
    fi
    echo ""
    
    # Storage
    echo -e "${BOLD}Storage:${NC}"
    if storage=$(api_get "/api/node/storage" 2>/dev/null); then
        echo "$storage" | jq -C '.' || echo "$storage"
    fi
    echo ""
    
    # Network
    echo -e "${BOLD}Network:${NC}"
    if network=$(api_get "/api/node/network" 2>/dev/null); then
        echo "$network" | jq -C '.' || echo "$network"
    fi
    echo ""
}

cmd_heartbeat() {
    check_authenticated
    
    if ! check_service_running; then
        log_error "Service not running"
        exit $EXIT_ERROR
    fi
    
    if heartbeat=$(api_get "/api/node/heartbeat" 2>/dev/null); then
        echo "$heartbeat" | jq -C '.' || echo "$heartbeat"
    else
        log_error "Failed to fetch heartbeat data"
        exit $EXIT_API_ERROR
    fi
}

# ============================================================================
# VM MANAGEMENT COMMANDS
# ============================================================================

cmd_vm_list() {
    check_authenticated
    
    if ! check_service_running; then
        log_error "Service not running"
        exit $EXIT_ERROR
    fi
    
    echo ""
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}  Virtual Machines${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo ""
    
    if vms=$(api_get "/api/vms" 2>/dev/null); then
        if [[ $(echo "$vms" | jq -r 'length' 2>/dev/null) -eq 0 ]]; then
            log_info "No VMs found"
        else
            echo "$vms" | jq -r '.[] | "\(.vmId)\t\(.name)\t\(.state)\t\(.spec.virtualCpuCores) cores\t\(.spec.memoryBytes) Bytes"' | \
                column -t -s $'\t' -N "VM ID,NAME,STATE,CPU,MEMORY" || echo "$vms"
        fi
    else
        log_error "Failed to fetch VM list"
        exit $EXIT_API_ERROR
    fi
    
    echo ""
}

cmd_vm_info() {
    local vm_id="$1"
    check_authenticated
    
    if [[ -z "$vm_id" ]]; then
        log_error "VM ID required"
        echo "Usage: $SCRIPT_NAME vm info <vm-id>"
        exit $EXIT_USAGE
    fi
    
    if ! check_service_running; then
        log_error "Service not running"
        exit $EXIT_ERROR
    fi
    
    if vm_info=$(api_get "/api/vms/$vm_id" 2>/dev/null); then
        echo "$vm_info" | jq -C '.' || echo "$vm_info"
    else
        log_error "Failed to fetch VM information for: $vm_id"
        exit $EXIT_API_ERROR
    fi
}

cmd_vm_cleanup() {
    check_root
    check_dependencies virsh
    
    local vm_id="${1:-}"
    local all_flag="${2:-}"
    local dry_run=false
    local force=false
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --all)
                all_flag="--all"
                shift
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            --force)
                force=true
                shift
                ;;
            *)
                if [[ -z "$vm_id" ]]; then
                    vm_id="$1"
                fi
                shift
                ;;
        esac
    done
    
    echo ""
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}  VM Cleanup${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo ""
    
    # Check for vm-cleanup.sh script
    local cleanup_script="/usr/local/bin/vm-cleanup.sh"
    if [[ ! -f "$cleanup_script" ]]; then
        log_error "VM cleanup script not found: $cleanup_script"
        exit $EXIT_ERROR
    fi
    
    # Build command
    local cmd="$cleanup_script"
    
    if [[ "$all_flag" == "--all" ]]; then
        cmd="$cmd --all"
    elif [[ -n "$vm_id" ]]; then
        cmd="$cmd --vm $vm_id"
    else
        log_error "Must specify either VM ID or --all"
        echo "Usage: $SCRIPT_NAME vm cleanup <vm-id>"
        echo "       $SCRIPT_NAME vm cleanup --all"
        exit $EXIT_USAGE
    fi
    
    [[ "$dry_run" == true ]] && cmd="$cmd --dry-run"
    [[ "$force" == true ]] && cmd="$cmd --force"
    
    # Execute cleanup
    log_debug "Running: $cmd"
    exec $cmd
}

# ============================================================================
# SERVICE MANAGEMENT COMMANDS
# ============================================================================

cmd_start() {
    check_root
    
    log_info "Starting DeCloud node agent..."
    
    if systemctl start "$SERVICE_NAME"; then
        log_success "Service started"
        
        # Wait a moment for service to initialize
        sleep 2
        
        if systemctl is-active --quiet "$SERVICE_NAME"; then
            log_success "Service is running"
        else
            log_error "Service failed to start"
            log_info "Check logs with: journalctl -u $SERVICE_NAME -n 50"
            exit $EXIT_ERROR
        fi
    else
        log_error "Failed to start service"
        exit $EXIT_ERROR
    fi
}

cmd_stop() {
    check_root
    
    log_info "Stopping DeCloud node agent..."
    
    if systemctl stop "$SERVICE_NAME"; then
        log_success "Service stopped"
    else
        log_error "Failed to stop service"
        exit $EXIT_ERROR
    fi
}

cmd_restart() {
    check_root
    
    log_info "Restarting DeCloud node agent..."
    
    if systemctl restart "$SERVICE_NAME"; then
        log_success "Service restarted"
        
        # Wait a moment for service to initialize
        sleep 2
        
        if systemctl is-active --quiet "$SERVICE_NAME"; then
            log_success "Service is running"
        else
            log_error "Service failed to start"
            log_info "Check logs with: journalctl -u $SERVICE_NAME -n 50"
            exit $EXIT_ERROR
        fi
    else
        log_error "Failed to restart service"
        exit $EXIT_ERROR
    fi
}

cmd_reset() {
    check_root
    
    local force=false
    local keep_vms=false
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force)
                force=true
                shift
                ;;
            --keep-vms)
                keep_vms=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    echo ""
    echo -e "${RED}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}  ⚠️  DESTRUCTIVE OPERATION - NODE RESET${NC}"
    echo -e "${RED}═══════════════════════════════════════════════════════════${NC}"
    echo ""
    echo -e "${YELLOW}This will perform the following actions:${NC}"
    echo ""
    echo "  1. Stop the node agent service"
    echo "  2. Remove authentication credentials"
    echo "  3. Clear all node agent logs"
    if [[ "$keep_vms" == false ]]; then
        echo "  4. Delete ALL virtual machines and their data"
        echo "  5. Restart the node agent service"
    else
        echo "  4. Keep VMs intact (--keep-vms specified)"
        echo "  5. Restart the node agent service"
    fi
    echo ""
    echo -e "${RED}WARNING: This action is IRREVERSIBLE!${NC}"
    echo ""
    
    if [[ "$force" == false ]]; then
        echo -e "${YELLOW}You will need to re-authenticate after reset.${NC}"
        echo ""
        read -p "Type 'RESET' to confirm this action: " confirmation
        
        if [[ "$confirmation" != "RESET" ]]; then
            log_info "Reset cancelled"
            exit 0
        fi
    fi
    
    echo ""
    log_info "Starting node reset..."
    echo ""
    
    # Step 1: Stop service
    log_info "[1/5] Stopping node agent service..."
    if systemctl stop "$SERVICE_NAME" 2>/dev/null; then
        log_success "Service stopped"
    else
        log_warn "Service was not running"
    fi
    sleep 2
    
    # Step 2: Remove credentials
    log_info "[2/5] Removing authentication credentials..."
    local creds_removed=0
    
    if [[ -f "$CREDENTIALS_FILE" ]]; then
        rm -f "$CREDENTIALS_FILE"
        log_success "Credentials removed"
        ((creds_removed++))
    fi
    
    if [[ -f "$PENDING_AUTH_FILE" ]]; then
        rm -f "$PENDING_AUTH_FILE"
        log_success "Pending auth removed"
        ((creds_removed++))
    fi
    
    if [[ $creds_removed -eq 0 ]]; then
        log_info "No credentials found"
    fi
    
    # Step 3: Clear logs
    log_info "[3/5] Clearing node agent logs..."
    if [[ -d "$LOG_DIR" ]]; then
        # Clear log files but keep directory
        find "$LOG_DIR" -type f -name "*.log" -delete 2>/dev/null || true
        log_success "Logs cleared"
    else
        log_info "No log directory found"
    fi
    
    # Also clear systemd journal for this service
    journalctl --rotate >/dev/null 2>&1 || true
    journalctl --vacuum-time=1s >/dev/null 2>&1 || true
    log_success "Systemd journal vacuumed"
    
    # Step 4: Clean up VMs
    if [[ "$keep_vms" == false ]]; then
        log_info "[4/5] Cleaning up ALL virtual machines..."
        
        # Check if vm-cleanup.sh exists
        if [[ -f "/usr/local/bin/vm-cleanup.sh" ]]; then
            # Use vm-cleanup.sh script
            /usr/local/bin/vm-cleanup.sh --all --force >/dev/null 2>&1 || {
                log_warn "VM cleanup script encountered errors (may be OK)"
            }
            log_success "All VMs cleaned up"
        else
            # Fallback: manual cleanup
            log_warn "vm-cleanup.sh not found, performing manual cleanup..."
            
            # Stop and undefine all VMs
            local vm_count=0
            while IFS= read -r vm_id; do
                if [[ -n "$vm_id" ]]; then
                    virsh destroy "$vm_id" 2>/dev/null || true
                    virsh undefine "$vm_id" --remove-all-storage 2>/dev/null || true
                    ((vm_count++))
                fi
            done < <(virsh list --all --uuid 2>/dev/null)
            
            # Clean VM storage directory
            if [[ -d "$VM_STORAGE_PATH" ]]; then
                rm -rf "${VM_STORAGE_PATH:?}"/* 2>/dev/null || true
            fi
            
            log_success "Cleaned up $vm_count VMs manually"
        fi
    else
        log_info "[4/5] Skipping VM cleanup (--keep-vms specified)"
    fi
    
    # Step 5: Restart service
    log_info "[5/5] Restarting node agent service..."
    if systemctl start "$SERVICE_NAME" 2>/dev/null; then
        sleep 3
        
        if systemctl is-active --quiet "$SERVICE_NAME"; then
            log_success "Service restarted successfully"
        else
            log_error "Service failed to start"
            log_info "Check logs with: journalctl -u $SERVICE_NAME -n 50"
        fi
    else
        log_error "Failed to restart service"
    fi
    
    echo ""
    echo -e "${GREEN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}  Reset Complete!${NC}"
    echo -e "${GREEN}═══════════════════════════════════════════════════════════${NC}"
    echo ""
    echo "Node has been reset to factory state."
    echo ""
    echo "Next steps:"
    echo "  1. Re-authenticate: ${BOLD}sudo $SCRIPT_NAME login${NC}"
    echo "  2. Check status:    ${BOLD}$SCRIPT_NAME status${NC}"
    echo "  3. Monitor logs:    ${BOLD}$SCRIPT_NAME logs -f${NC}"
    echo ""
}

cmd_logs() {
    local lines="${1:-50}"
    local follow=false
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -f|--follow)
                follow=true
                shift
                ;;
            -n|--lines)
                lines="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done
    
    if [[ "$follow" == true ]]; then
        exec journalctl -u "$SERVICE_NAME" -f
    else
        exec journalctl -u "$SERVICE_NAME" -n "$lines" --no-pager
    fi
}

# ============================================================================
# DIAGNOSTIC COMMANDS
# ============================================================================

cmd_diagnose() {
    echo ""
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}  DeCloud Node Agent Diagnostics${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo ""
    
    # 1. Check service
    echo -e "${BOLD}1. Service Status${NC}"
    if systemctl is-active --quiet "$SERVICE_NAME"; then
        log_success "Service is running"
    else
        log_error "Service is not running"
        echo "  Start with: sudo $SCRIPT_NAME start"
    fi
    echo ""
    
    # 2. Check authentication
    echo -e "${BOLD}2. Authentication${NC}"
    if [[ -f "$CREDENTIALS_FILE" ]]; then
        log_success "Credentials file exists"
        
        local node_id=$(get_node_id)
        if [[ -n "$node_id" ]]; then
            echo "  Node ID: $node_id"
        else
            log_warn "Node ID not found in credentials"
        fi
    else
        log_error "Not authenticated"
        echo "  Run: sudo $SCRIPT_NAME login"
    fi
    echo ""
    
    # 3. Check libvirt
    echo -e "${BOLD}3. Virtualization (libvirt)${NC}"
    if command -v virsh &>/dev/null; then
        log_success "virsh command available"
        
        if systemctl is-active --quiet libvirtd; then
            log_success "libvirtd service is running"
        else
            log_error "libvirtd service is not running"
            echo "  Start with: sudo systemctl start libvirtd"
        fi
        
        # Check VM count
        local vm_count=$(virsh list --all --uuid 2>/dev/null | grep -v '^$' | wc -l)
        echo "  VMs in libvirt: $vm_count"
    else
        log_error "virsh not found (libvirt not installed)"
    fi
    echo ""
    
    # 4. Check WireGuard
    echo -e "${BOLD}4. WireGuard${NC}"
    if command -v wg &>/dev/null; then
        log_success "wg command available"
        
        if wg show &>/dev/null; then
            local interfaces=$(wg show interfaces)
            if [[ -n "$interfaces" ]]; then
                log_success "WireGuard interfaces active"
                echo "  Interfaces: $interfaces"
            else
                log_warn "No WireGuard interfaces active"
            fi
        else
            log_warn "Cannot query WireGuard (may need root)"
        fi
    else
        log_error "WireGuard not installed"
    fi
    echo ""
    
    # 5. Check network connectivity
    echo -e "${BOLD}5. Network Connectivity${NC}"
    if check_service_running && [[ -f "$CREDENTIALS_FILE" ]]; then
        if status=$(api_get "/api/node/network/status" 2>/dev/null); then
            local internet=$(echo "$status" | jq -r '.isInternetReachable // "unknown"' 2>/dev/null)
            local orchestrator=$(echo "$status" | jq -r '.isOrchestratorReachable // "unknown"' 2>/dev/null)
            
            if [[ "$internet" == "true" ]]; then
                log_success "Internet reachable"
            else
                log_error "Internet unreachable"
            fi
            
            if [[ "$orchestrator" == "true" ]]; then
                log_success "Orchestrator reachable"
            else
                log_error "Orchestrator unreachable"
            fi
        else
            log_warn "Cannot fetch heartbeat data"
        fi
    else
        log_warn "Cannot check (service not running or not authenticated)"
    fi
    echo ""
    
    # 6. Check disk space
    echo -e "${BOLD}6. Disk Space${NC}"
    if [[ -d "$VM_STORAGE_PATH" ]]; then
        local usage=$(df -h "$VM_STORAGE_PATH" | tail -1 | awk '{print $5}')
        local available=$(df -h "$VM_STORAGE_PATH" | tail -1 | awk '{print $4}')
        echo "  VM Storage: $usage used, $available available"
        
        # Warning if > 80% used
        local usage_percent=$(echo "$usage" | tr -d '%')
        if [[ "$usage_percent" -gt 80 ]]; then
            log_warn "Disk space usage is high (${usage})"
        else
            log_success "Disk space OK (${usage})"
        fi
    else
        log_warn "VM storage directory not found: $VM_STORAGE_PATH"
    fi
    echo ""
    
    # 7. Check recent errors
    echo -e "${BOLD}7. Recent Errors${NC}"
    local error_count=$(journalctl -u "$SERVICE_NAME" --since "10 minutes ago" -p err --no-pager 2>/dev/null | grep -c "." || echo "0")
    if [[ "$error_count" -gt 0 ]]; then
        log_warn "Found $error_count errors in last 10 minutes"
        echo "  View with: $SCRIPT_NAME logs -n 50"
    else
        log_success "No recent errors"
    fi
    echo ""
    
    # Summary
    echo -e "${BOLD}Diagnostic Summary:${NC}"
    echo "  Run '$SCRIPT_NAME status' for current status"
    echo "  Run '$SCRIPT_NAME logs' to view service logs"
    echo ""
}

cmd_test_api() {
    echo ""
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}  Node Agent API Test${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo ""
    
    local endpoints=(
        "/health"
        "/api/node"
        "/api/node/cpu"
        "/api/node/memory"
        "/api/node/storage"
    )
    
    for endpoint in "${endpoints[@]}"; do
        echo -n "Testing $endpoint ... "
        
        if response=$(api_get "$endpoint" 2>/dev/null); then
            log_success "OK"
            [[ "${VERBOSE:-0}" == "1" ]] && echo "$response" | jq -C '.'
        else
            log_error "FAILED"
        fi
    done
    
    echo ""
}

# ============================================================================
# HELP & VERSION
# ============================================================================

cmd_version() {
    echo "DeCloud Node Agent CLI v$VERSION"
}

cmd_help() {
    cat << EOF
${BOLD}DeCloud Node Agent CLI${NC}

A unified command-line tool for managing DeCloud node agent operations.

${BOLD}USAGE:${NC}
    $SCRIPT_NAME <command> [options]

${BOLD}AUTHENTICATION COMMANDS:${NC}
    login               Authenticate node with wallet signature
    logout              Remove node authentication
    status              Show comprehensive node status

${BOLD}INFORMATION COMMANDS:${NC}
    info                Display detailed node information
    resources           Display resource information (CPU, memory, storage)
    heartbeat           Display last heartbeat data
    version             Display CLI version

${BOLD}VM MANAGEMENT:${NC}
    vm list             List all VMs on this node
    vm info <vm-id>     Display detailed VM information
    vm cleanup <vm-id>  Clean up a specific VM
    vm cleanup --all    Clean up all VMs (with confirmation)

${BOLD}SERVICE MANAGEMENT:${NC}
    start               Start the node agent service
    stop                Stop the node agent service
    restart             Restart the node agent service
    reset               Reset node to factory state (DESTRUCTIVE!)
        --force             Skip confirmation prompt
        --keep-vms          Don't delete VMs during reset
    logs [options]      View service logs
        -f, --follow        Follow log output
        -n, --lines <n>     Number of lines to show (default: 50)

${BOLD}DIAGNOSTIC COMMANDS:${NC}
    diagnose            Run comprehensive diagnostics
    test-api            Test node agent API endpoints

${BOLD}OPTIONS:${NC}
    -h, --help          Display this help message
    -v, --version       Display version information
    --debug             Enable debug output

${BOLD}EXAMPLES:${NC}
    # Authenticate node
    sudo $SCRIPT_NAME login

    # Check node status
    $SCRIPT_NAME status

    # View service logs (follow)
    $SCRIPT_NAME logs -f

    # List VMs
    $SCRIPT_NAME vm list

    # Clean up specific VM
    sudo $SCRIPT_NAME vm cleanup abc-123-def

    # Run diagnostics
    $SCRIPT_NAME diagnose

    # Reset node to factory state (removes auth, cleans VMs, clears logs)
    sudo $SCRIPT_NAME reset

${BOLD}ENVIRONMENT VARIABLES:${NC}
    DEBUG=1             Enable debug output
    NODE_AGENT_URL      Override node agent URL (default: http://localhost:5100)

${BOLD}FILES:${NC}
    $CREDENTIALS_FILE
    $PENDING_AUTH_FILE
    $VM_STORAGE_PATH

${BOLD}SEE ALSO:${NC}
    journalctl(1), systemctl(1), virsh(1)

For more information, visit: https://docs.decloud.io

EOF
}

# ============================================================================
# COMMAND ROUTER
# ============================================================================

main() {
    # Parse global options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --debug)
                export DEBUG=1
                shift
                ;;
            -h|--help|help)
                cmd_help
                exit $EXIT_SUCCESS
                ;;
            -v|--version)
                cmd_version
                exit $EXIT_SUCCESS
                ;;
            -*)
                log_error "Unknown option: $1"
                echo "Run '$SCRIPT_NAME --help' for usage information"
                exit $EXIT_USAGE
                ;;
            *)
                break
                ;;
        esac
    done
    
    # Require command
    if [[ $# -eq 0 ]]; then
        cmd_help
        exit $EXIT_USAGE
    fi
    
    # Route command
    local command="$1"
    shift
    
    case "$command" in
        # Authentication
        login)
            cmd_login "$@"
            ;;
        logout)
            cmd_logout "$@"
            ;;
        
        # Status & Info
        status)
            cmd_status "$@"
            ;;
        info)
            cmd_info "$@"
            ;;
        resources)
            cmd_resources "$@"
            ;;
        heartbeat)
            cmd_heartbeat "$@"
            ;;
        
        # VM Management
        vm)
            if [[ $# -eq 0 ]]; then
                log_error "VM subcommand required"
                echo "Usage: $SCRIPT_NAME vm <list|info|cleanup>"
                exit $EXIT_USAGE
            fi
            
            local vm_command="$1"
            shift
            
            case "$vm_command" in
                list|ls)
                    cmd_vm_list "$@"
                    ;;
                info|show)
                    cmd_vm_info "$@"
                    ;;
                cleanup|clean|delete|rm)
                    cmd_vm_cleanup "$@"
                    ;;
                *)
                    log_error "Unknown VM command: $vm_command"
                    echo "Valid commands: list, info, cleanup"
                    exit $EXIT_USAGE
                    ;;
            esac
            ;;
        
        # Service Management
        start)
            cmd_start "$@"
            ;;
        stop)
            cmd_stop "$@"
            ;;
        restart)
            cmd_restart "$@"
            ;;
        reset)
            cmd_reset "$@"
            ;;
        logs)
            cmd_logs "$@"
            ;;
        
        # Diagnostics
        diagnose|diag)
            cmd_diagnose "$@"
            ;;
        test-api)
            cmd_test_api "$@"
            ;;
        
        # Version
        version)
            cmd_version
            ;;
        
        # Unknown command
        *)
            log_error "Unknown command: $command"
            echo "Run '$SCRIPT_NAME --help' for usage information"
            exit $EXIT_USAGE
            ;;
    esac
}

# ============================================================================
# ENTRY POINT
# ============================================================================

# Trap errors
trap 'log_error "Command failed with exit code $?"' ERR

# Run main
main "$@"
