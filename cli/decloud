#!/usr/bin/env bash

#═══════════════════════════════════════════════════════════════════════════
# DeCloud Node Agent CLI
# Version: 1.0.0
#
# A unified CLI tool for managing DeCloud node agent operations
# Inspired by: docker, kubectl, systemctl
#
# Usage:
#   decloud <command> [options]
#   decloud --help
#═══════════════════════════════════════════════════════════════════════════

set -euo pipefail

# ============================================================================
# GLOBAL CONSTANTS
# ============================================================================

readonly VERSION="1.3.0"
readonly SCRIPT_NAME="$(basename "$0")"
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Configuration paths
readonly CONFIG_DIR="/etc/decloud"
readonly CREDENTIALS_FILE="$CONFIG_DIR/credentials"
readonly PENDING_AUTH_FILE="$CONFIG_DIR/pending-auth"
readonly VM_STORAGE_PATH="/var/lib/decloud/vms"
readonly BACKUP_PATH="/var/backups/decloud"
readonly LOG_DIR="/var/log/decloud"
readonly LOG_FILE="$LOG_DIR/nodeagent.log"

# Service name
readonly SERVICE_NAME="decloud-node-agent"

# Node agent API
readonly NODE_AGENT_URL="http://localhost:5100"

# Colors
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly CYAN='\033[0;36m'
readonly BOLD='\033[1m'
readonly NC='\033[0m' # No Color

# Exit codes
readonly EXIT_SUCCESS=0
readonly EXIT_ERROR=1
readonly EXIT_USAGE=2
readonly EXIT_NO_AUTH=3
readonly EXIT_API_ERROR=4

# ============================================================================
# LOGGING FUNCTIONS
# ============================================================================

log_info() {
    echo -e "${BLUE}[INFO]${NC} $*"
}

log_success() {
    echo -e "${GREEN}[✓]${NC} $*"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $*" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

log_debug() {
    if [[ "${DEBUG:-0}" == "1" ]]; then
        echo -e "${CYAN}[DEBUG]${NC} $*" >&2
    fi
}

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

check_root() {
    if [[ $EUID -ne 0 ]]; then
        log_error "This command requires root privileges"
        log_info "Please run with sudo: sudo $SCRIPT_NAME $*"
        exit $EXIT_ERROR
    fi
}

check_not_root() {
    if [[ $EUID -eq 0 ]]; then
        log_error "This command should not be run as root"
        exit $EXIT_ERROR
    fi
}

check_dependencies() {
    local missing_deps=()
    
    for cmd in "$@"; do
        if ! command -v "$cmd" &>/dev/null; then
            missing_deps+=("$cmd")
        fi
    done
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        log_error "Missing required dependencies: ${missing_deps[*]}"
        return 1
    fi
    
    return 0
}

check_service_running() {
    if ! systemctl is-active --quiet "$SERVICE_NAME"; then
        log_warn "Node agent service is not running"
        return 1
    fi
    return 0
}

check_authenticated() {
    if [[ ! -f "$CREDENTIALS_FILE" ]]; then
        log_error "Node not authenticated"
        log_info "Run: $SCRIPT_NAME login"
        exit $EXIT_NO_AUTH
    fi
}

get_node_id() {
    if [[ -f "$CREDENTIALS_FILE" ]]; then
        grep "^NODE_ID=" "$CREDENTIALS_FILE" | cut -d= -f2 || echo ""
    else
        echo ""
    fi
}

get_machine_id() {
    if [[ -f /etc/machine-id ]]; then
        cat /etc/machine-id
    else
        log_error "Cannot read /etc/machine-id"
        exit $EXIT_ERROR
    fi
}

# ============================================================================
# API FUNCTIONS
# ============================================================================

api_call() {
    local method="$1"
    local endpoint="$2"
    local data="${3:-}"
    
    local url="${NODE_AGENT_URL}${endpoint}"
    local response
    local http_code
    
    log_debug "API $method $url"
    
    if [[ -n "$data" ]]; then
        response=$(curl -s -w "\n%{http_code}" -X "$method" \
            -H "Content-Type: application/json" \
            -d "$data" \
            "$url" 2>&1)
    else
        response=$(curl -s -w "\n%{http_code}" -X "$method" "$url" 2>&1)
    fi
    
    http_code=$(echo "$response" | tail -n1)
    response=$(echo "$response" | sed '$d')
    
    log_debug "HTTP $http_code: $response"
    
    if [[ "$http_code" -ge 200 && "$http_code" -lt 300 ]]; then
        echo "$response"
        return 0
    else
        log_error "API error (HTTP $http_code): $response"
        return 1
    fi
}

api_get() {
    api_call "GET" "$1"
}

api_post() {
    api_call "POST" "$1" "$2"
}

api_delete() {
    api_call "DELETE" "$1"
}

# ============================================================================
# AUTHENTICATION COMMANDS
# ============================================================================

cmd_login() {
    check_root
    
    log_info "Starting node authentication..."
    
    if ! command -v cli-decloud-node &>/dev/null; then
        log_error "Authentication CLI not found"
        log_info "Please install the DeCloud node agent first"
        exit $EXIT_ERROR
    fi
    
    # Delegate to Python CLI for wallet authentication
    exec cli-decloud-node login "$@"
}

cmd_logout() {
    check_root
    
    log_info "Logging out node..."
    
    if ! command -v cli-decloud-node &>/dev/null; then
        log_error "Authentication CLI not found"
        exit $EXIT_ERROR
    fi
    
    # Delegate to Python CLI
    exec cli-decloud-node logout "$@"
}

# ============================================================================
# STATUS & INFO COMMANDS
# ============================================================================

cmd_status() {
    echo ""
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}  DeCloud Node Agent Status${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo ""
    
    # Authentication status
    echo -e "${BOLD}Authentication:${NC}"
    if [[ -f "$CREDENTIALS_FILE" ]]; then
        local node_id=$(get_node_id)
        local wallet=$(grep "^WALLET_ADDRESS=" "$CREDENTIALS_FILE" | cut -d= -f2 || echo "Unknown")
        local api_key=$(grep "^API_KEY=" "$CREDENTIALS_FILE" | cut -d= -f2 || echo "Unknown")
        
        log_success "Authenticated"
        echo "  Node ID:  $node_id"
        echo "  Wallet:   $wallet"
        echo "  API Key:  ${api_key:0:20}..."
    else
        log_warn "Not authenticated"
        echo "  Run: $SCRIPT_NAME login"
    fi
    echo ""
    
    # Service status
    echo -e "${BOLD}Service:${NC}"
    if systemctl is-active --quiet "$SERVICE_NAME"; then
        log_success "Running"
        
        # Uptime
        local uptime=$(systemctl show -p ActiveEnterTimestamp "$SERVICE_NAME" | cut -d= -f2)
        if [[ -n "$uptime" ]]; then
            echo "  Started:  $uptime"
        fi
        
        # Memory usage
        local memory=$(systemctl show -p MemoryCurrent "$SERVICE_NAME" | cut -d= -f2)
        if [[ -n "$memory" && "$memory" != "[not set]" ]]; then
            local memory_mb=$((memory / 1024 / 1024))
            echo "  Memory:   ${memory_mb}MB"
        fi
    else
        log_warn "Not running"
        echo "  Start with: sudo systemctl start $SERVICE_NAME"
    fi
    echo ""
    
    # Health check
    echo -e "${BOLD}Health:${NC}"
    if check_service_running; then
        if health=$(api_get "/api/node/health" 2>/dev/null); then
            log_success "API responding"
            echo "$health" | jq -r '  .status' 2>/dev/null || echo "$health"
        else
            log_warn "API not responding"
        fi
    else
        log_warn "Service not running"
    fi
    echo ""
    
    # VM count
    echo -e "${BOLD}Virtual Machines:${NC}"
    if [[ -f "$CREDENTIALS_FILE" ]] && check_service_running; then
        if vms=$(api_get "/api/vms" 2>/dev/null); then
            local total=$(echo "$vms" | jq -r 'length' 2>/dev/null || echo "0")
            local running=$(echo "$vms" | jq -r '[.[] | select(.state == 3)] | length' 2>/dev/null || echo "0")
            echo "  Total:    $total"
            echo "  Running:  $running"
        else
            echo "  Unable to fetch VM data"
        fi
    else
        echo "  Not available (not authenticated or service not running)"
    fi
    echo ""
    
    # Network status
    echo -e "${BOLD}Network:${NC}"
    if check_service_running && [[ -f "$CREDENTIALS_FILE" ]]; then
        if status=$(api_get "/api/node/network/status" 2>/dev/null); then
            local internet=$(echo "$status" | jq -r '.isInternetReachable // "unknown"' 2>/dev/null)
            local orchestrator=$(echo "$status" | jq -r '.isOrchestratorReachable // "unknown"' 2>/dev/null)
            
            if [[ "$internet" == "true" ]]; then
                log_success "Internet reachable"
            else
                log_warn "Internet unreachable"
            fi
            
            if [[ "$orchestrator" == "true" ]]; then
                log_success "Orchestrator reachable"
            else
                log_warn "Orchestrator unreachable"
            fi
        fi
    else
        echo "  Not available"
    fi
    echo ""
}

cmd_info() {
    check_authenticated
    
    echo ""
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}  Node Information${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo ""
    
    if ! check_service_running; then
        log_error "Service not running"
        exit $EXIT_ERROR
    fi
    
    # Get detailed node info from API
    if node_info=$(api_get "/api/node" 2>/dev/null); then
        echo "$node_info" | jq -C '.' || echo "$node_info"
    else
        log_error "Failed to fetch node information"
        exit $EXIT_API_ERROR
    fi
    
    echo ""
}

cmd_resources() {
    check_authenticated
    
    echo ""
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}  Resource Information${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo ""
    
    if ! check_service_running; then
        log_error "Service not running"
        exit $EXIT_ERROR
    fi
    
    # CPU
    echo -e "${BOLD}CPU:${NC}"
    if cpu=$(api_get "/api/node/cpu" 2>/dev/null); then
        echo "$cpu" | jq -C '.' || echo "$cpu"
    fi
    echo ""
    
    # Memory
    echo -e "${BOLD}Memory:${NC}"
    if memory=$(api_get "/api/node/memory" 2>/dev/null); then
        echo "$memory" | jq -C '.' || echo "$memory"
    fi
    echo ""
    
    # Storage
    echo -e "${BOLD}Storage:${NC}"
    if storage=$(api_get "/api/node/storage" 2>/dev/null); then
        echo "$storage" | jq -C '.' || echo "$storage"
    fi
    echo ""
    
    # Network
    echo -e "${BOLD}Network:${NC}"
    if network=$(api_get "/api/node/network" 2>/dev/null); then
        echo "$network" | jq -C '.' || echo "$network"
    fi
    echo ""
}

cmd_heartbeat() {
    check_authenticated
    
    if ! check_service_running; then
        log_error "Service not running"
        exit $EXIT_ERROR
    fi
    
    if heartbeat=$(api_get "/api/node/heartbeat" 2>/dev/null); then
        echo "$heartbeat" | jq -C '.' || echo "$heartbeat"
    else
        log_error "Failed to fetch heartbeat data"
        exit $EXIT_API_ERROR
    fi
}

# ============================================================================
# ORCHESTRATOR DIAGNOSTIC COMMANDS
# ============================================================================

cmd_performance() {
    check_authenticated
    
    echo ""
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}  Node Performance Evaluation${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo ""
    
    if ! check_service_running; then
        log_error "Service not running"
        exit $EXIT_ERROR
    fi
    
    # Query node agent orchestrator proxy
    if perf=$(api_get "/api/orchestrator/performance" 2>/dev/null); then
        # Parse actual C# model fields
        local benchmark=$(echo "$perf" | jq -r '.benchmarkScore // "N/A"')
        local capped=$(echo "$perf" | jq -r '.cappedBenchmarkScore // "N/A"')
        local points_per_core=$(echo "$perf" | jq -r '.pointsPerCore // "N/A"')
        local total_points=$(echo "$perf" | jq -r '.totalComputePoints // "N/A"')
        local highest_tier=$(echo "$perf" | jq -r '.highestTier // "N/A"')
        local is_acceptable=$(echo "$perf" | jq -r '.isAcceptable // "N/A"')
        
        echo -e "${BOLD}Benchmark Scores:${NC}"
        echo "  Raw Score:        $benchmark"
        echo "  Capped Score:     $capped"
        echo "  Points per Core:  $(printf "%.2f" "$points_per_core" 2>/dev/null || echo "$points_per_core")"
        echo "  Total Points:     $(printf "%.0f" "$total_points" 2>/dev/null || echo "$total_points")"
        echo ""
        
        echo -e "${BOLD}Tier Eligibility:${NC}"
        echo "  Highest Tier:     ${BOLD}$highest_tier${NC}"
        echo "  Is Acceptable:    $is_acceptable"
        echo ""
        
        # Show eligible tiers from EligibleTiers array
        echo -e "${BOLD}Eligible Tiers:${NC}"
        if echo "$perf" | jq -e '.eligibleTiers' >/dev/null 2>&1; then
            local tiers=$(echo "$perf" | jq -r '.eligibleTiers[]' 2>/dev/null)
            if [[ -n "$tiers" ]]; then
                echo "$tiers" | while read -r tier; do
                    echo "  • $tier"
                done
            else
                echo "  No tier data available"
            fi
        else
            echo "  No tier data available"
        fi
        echo ""
        
        # Show tier capabilities if available
        if echo "$perf" | jq -e '.tierCapabilities' >/dev/null 2>&1; then
            echo -e "${BOLD}Tier Capabilities:${NC}"
            echo "$perf" | jq -r '.tierCapabilities | to_entries[] | "  \(.key): Max \(.value.maxVCpus) vCPUs"' 2>/dev/null || echo "  No capability data"
            echo ""
        fi
        
        # Raw JSON for detailed inspection
        if [[ "${VERBOSE:-0}" == "1" ]] || [[ "${DEBUG:-0}" == "1" ]]; then
            echo -e "${BOLD}Raw Data:${NC}"
            echo "$perf" | jq -C '.'
            echo ""
        fi
    else
        log_error "Failed to fetch performance evaluation from orchestrator"
        log_info "Ensure orchestrator is reachable: decloud diagnose"
        exit $EXIT_API_ERROR
    fi
}

cmd_capacity() {
    check_authenticated
    
    echo ""
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}  Node Capacity & Allocation${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo ""
    
    if ! check_service_running; then
        log_error "Service not running"
        exit $EXIT_ERROR
    fi
    
    if capacity=$(api_get "/api/orchestrator/capacity" 2>/dev/null); then
        # Parse physical resources (note: using actual C# property names)
        local cpu_cores=$(echo "$capacity" | jq -r '.physicalCores // "N/A"')
        local memory_bytes=$(echo "$capacity" | jq -r '.physicalMemoryBytes // "N/A"')
        local storage_bytes=$(echo "$capacity" | jq -r '.physicalStorageBytes // "N/A"')
        
        # Convert bytes to GB
        local memory_gb="N/A"
        local storage_gb="N/A"
        if [[ "$memory_bytes" != "N/A" ]] && [[ "$memory_bytes" =~ ^[0-9]+$ ]]; then
            memory_gb=$(awk "BEGIN {printf \"%.2f\", $memory_bytes / (1024^3)}")
        fi
        if [[ "$storage_bytes" != "N/A" ]] && [[ "$storage_bytes" =~ ^[0-9]+$ ]]; then
            storage_gb=$(awk "BEGIN {printf \"%.2f\", $storage_bytes / (1024^3)}")
        fi
        
        # Parse compute points
        local total_points=$(echo "$capacity" | jq -r '.totalComputePoints // "N/A"')
        local allocated_points=$(echo "$capacity" | jq -r '.allocatedComputePoints // "N/A"')
        local available_points=$(echo "$capacity" | jq -r '.availableComputePoints // "N/A"')
        local utilization=$(echo "$capacity" | jq -r '.utilizationPercent // "N/A"')
        local points_per_core=$(echo "$capacity" | jq -r '.pointsPerCore // "N/A"')
        
        # Parse memory allocation
        local allocated_memory=$(echo "$capacity" | jq -r '.allocatedMemoryBytes // "N/A"')
        local available_memory=$(echo "$capacity" | jq -r '.availableMemoryBytes // "N/A"')
        
        # Parse VM count
        local vm_count=$(echo "$capacity" | jq -r '.activeVmCount // "N/A"')
        
        echo -e "${BOLD}Physical Resources:${NC}"
        echo "  CPU Cores:    $cpu_cores"
        echo "  Memory:       ${memory_gb} GB"
        echo "  Storage:      ${storage_gb} GB"
        echo ""
        
        echo -e "${BOLD}Compute Points:${NC}"
        echo "  Points/Core:  $(printf "%.2f" "$points_per_core" 2>/dev/null || echo "$points_per_core")"
        echo "  Total:        $total_points"
        echo "  Allocated:    $allocated_points"
        echo "  Available:    $available_points"
        
        # Show utilization if available
        if [[ "$utilization" != "N/A" ]]; then
            echo "  Usage:        $(printf "%.1f" "$utilization" 2>/dev/null || echo "$utilization")%"
        fi
        echo ""
        
        echo -e "${BOLD}Current Allocations:${NC}"
        echo "  VMs:          $vm_count"
        
        # Show memory allocation if available
        if [[ "$allocated_memory" != "N/A" ]] && [[ "$allocated_memory" =~ ^[0-9]+$ ]]; then
            local allocated_memory_mb=$(awk "BEGIN {printf \"%.0f\", $allocated_memory / (1024^2)}")
            echo "  Memory:       ${allocated_memory_mb} MB allocated"
        fi
        echo ""
        
        # Show per-VM breakdown if available
        if echo "$capacity" | jq -e '.vmBreakdown' >/dev/null 2>&1; then
            local vm_count=$(echo "$capacity" | jq -r '.vmBreakdown | length' 2>/dev/null)
            if [[ "$vm_count" -gt 0 ]]; then
                echo -e "${BOLD}Per-VM Breakdown:${NC}"
                echo "$capacity" | jq -r '.vmBreakdown[] | "  • \(.vmId[0:8])... - \(.tier): \(.vCpus) vCPU, \(.points) pts, \(.status)"' 2>/dev/null || echo "  Unable to parse VM data"
                echo ""
            fi
        fi
        
        # Raw JSON for detailed inspection
        if [[ "${VERBOSE:-0}" == "1" ]] || [[ "${DEBUG:-0}" == "1" ]]; then
            echo -e "${BOLD}Raw Data:${NC}"
            echo "$capacity" | jq -C '.'
            echo ""
        fi
    else
        log_error "Failed to fetch capacity information from orchestrator"
        log_info "Ensure orchestrator is reachable: decloud diagnose"
        exit $EXIT_API_ERROR
    fi
}

cmd_node_config() {
    check_authenticated
    
    echo ""
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}  Scheduling Configuration${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo ""
    
    if ! check_service_running; then
        log_error "Service not running"
        exit $EXIT_ERROR
    fi
    
    if config=$(api_get "/api/orchestrator/config" 2>/dev/null); then
        # Parse configuration fields
        local version=$(echo "$config" | jq -r '.version // "N/A"')
        local baseline=$(echo "$config" | jq -r '.baselineBenchmark // "N/A"')
        local baseline_overcommit=$(echo "$config" | jq -r '.baselineOvercommitRatio // "N/A"')
        local max_perf_mult=$(echo "$config" | jq -r '.maxPerformanceMultiplier // "N/A"')
        local updated_at=$(echo "$config" | jq -r '.updatedAt // "N/A"')
        
        echo -e "${BOLD}Configuration:${NC}"
        echo "  Version:                $version"
        echo "  Baseline Benchmark:     $baseline"
        echo "  Baseline Overcommit:    $(printf "%.1f" "$baseline_overcommit" 2>/dev/null || echo "$baseline_overcommit")x"
        echo "  Max Performance Mult:   $(printf "%.1f" "$max_perf_mult" 2>/dev/null || echo "$max_perf_mult")x"
        echo "  Updated:                $updated_at"
        echo ""
        
        # Show tier configurations if available
        if echo "$config" | jq -e '.tiers' >/dev/null 2>&1; then
            echo -e "${BOLD}Tier Configurations:${NC}"
            echo ""
            
            # Parse tiers object (it's a dictionary)
            echo "$config" | jq -r '.tiers | to_entries[] | 
                "\u001b[1m\(.key)\u001b[0m\n" +
                "  Min Benchmark:      \(.value.minimumBenchmark)\n" +
                "  Points/vCPU:        \(.value.pointsPerVCpu // "N/A")\n" +
                "  Memory/vCPU:        \(.value.memoryMbPerVCpu) MB\n" +
                "  Max vCPUs:          \(.value.maxVCpus)\n" +
                "  CPU Overcommit:     \(.value.cpuOvercommitRatio)x\n"' 2>/dev/null || {
                log_warn "Unable to parse tier data"
            }
        fi
        
        # Raw JSON for detailed inspection
        if [[ "${VERBOSE:-0}" == "1" ]] || [[ "${DEBUG:-0}" == "1" ]]; then
            echo -e "${BOLD}Raw Data:${NC}"
            echo "$config" | jq -C '.'
            echo ""
        fi
    else
        log_error "Failed to fetch configuration from orchestrator"
        log_info "Ensure orchestrator is reachable: decloud diagnose"
        exit $EXIT_API_ERROR
    fi
}

cmd_node_summary() {
    check_authenticated
    
    echo ""
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}  Node Summary (Orchestrator View)${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo ""
    
    if ! check_service_running; then
        log_error "Service not running"
        exit $EXIT_ERROR
    fi
    
    if summary=$(api_get "/api/orchestrator/summary" 2>/dev/null); then
        # Parse key fields from NodeSummaryResponse
        local node_id=$(echo "$summary" | jq -r '.nodeId // "N/A"')
        local status=$(echo "$summary" | jq -r '.status // "N/A"')
        local region=$(echo "$summary" | jq -r '.region // "N/A"')
        local public_ip=$(echo "$summary" | jq -r '.publicIp // "N/A"')
        local agent_version=$(echo "$summary" | jq -r '.agentVersion // "N/A"')
        local registered=$(echo "$summary" | jq -r '.registeredAt // "N/A"')
        local last_heartbeat=$(echo "$summary" | jq -r '.lastHeartbeat // "N/A"')
        local config_version=$(echo "$summary" | jq -r '.schedulingConfigVersion // "N/A"')
        
        echo -e "${BOLD}Node Identity:${NC}"
        echo "  Node ID:       $node_id"
        echo "  Status:        $status"
        echo "  Public IP:     $public_ip"
        echo "  Region:        $region"
        echo ""
        
        echo -e "${BOLD}Software:${NC}"
        echo "  Agent Version: $agent_version"
        echo "  Config Ver:    $config_version"
        echo ""
        
        echo -e "${BOLD}Activity:${NC}"
        echo "  Registered:    $registered"
        echo "  Last Heartbeat:$last_heartbeat"
        echo ""
        
        # Raw JSON for detailed inspection
        if [[ "${VERBOSE:-0}" == "1" ]] || [[ "${DEBUG:-0}" == "1" ]]; then
            echo -e "${BOLD}Raw Data:${NC}"
            echo "$summary" | jq -C '.'
            echo ""
        fi
    else
        log_error "Failed to fetch node summary from orchestrator"
        log_info "Ensure orchestrator is reachable: decloud diagnose"
        exit $EXIT_API_ERROR
    fi
}

cmd_evaluate() {
    check_authenticated
    
    echo ""
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}  Request Performance Re-evaluation${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo ""
    
    if ! check_service_running; then
        log_error "Service not running"
        exit $EXIT_ERROR
    fi
    
    log_info "Requesting orchestrator to re-evaluate node performance..."
    echo ""
    
    # Note: This is a GET endpoint in the controller
    if result=$(api_get "/api/orchestrator/evaluate" 2>/dev/null); then
        log_success "Re-evaluation completed successfully"
        echo ""
        
        # Show new evaluation results (same format as NodePerformanceEvaluation)
        local benchmark=$(echo "$result" | jq -r '.benchmarkScore // "N/A"')
        local capped=$(echo "$result" | jq -r '.cappedBenchmarkScore // "N/A"')
        local points_per_core=$(echo "$result" | jq -r '.pointsPerCore // "N/A"')
        local total_points=$(echo "$result" | jq -r '.totalComputePoints // "N/A"')
        local highest_tier=$(echo "$result" | jq -r '.highestTier // "N/A"')
        
        echo -e "${BOLD}New Evaluation Results:${NC}"
        echo "  Raw Score:        $benchmark"
        echo "  Capped Score:     $capped"
        echo "  Points per Core:  $(printf "%.2f" "$points_per_core" 2>/dev/null || echo "$points_per_core")"
        echo "  Total Points:     $(printf "%.0f" "$total_points" 2>/dev/null || echo "$total_points")"
        echo "  Highest Tier:     $highest_tier"
        echo ""
        
        log_info "Use 'decloud performance' to see full evaluation details"
    else
        log_error "Failed to request re-evaluation"
        log_info "Ensure orchestrator is reachable: decloud diagnose"
        exit $EXIT_API_ERROR
    fi
    
    echo ""
}

# ============================================================================
# VM MANAGEMENT COMMANDS
# ============================================================================

cmd_vm_list() {
    check_authenticated
    
    if ! check_service_running; then
        log_error "Service not running"
        exit $EXIT_ERROR
    fi
    
    echo ""
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}  Virtual Machines${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo ""
    
    if vms=$(api_get "/api/vms" 2>/dev/null); then
        if [[ $(echo "$vms" | jq -r 'length' 2>/dev/null) -eq 0 ]]; then
            log_info "No VMs found"
        else
            echo "$vms" | jq -r '.[] | "\(.vmId)\t\(.name)\t\(.state)\t\(.spec.virtualCpuCores) cores\t\(.spec.memoryBytes) Bytes"' | \
                column -t -s $'\t' -N "VM ID,NAME,STATE,CPU,MEMORY" || echo "$vms"
        fi
    else
        log_error "Failed to fetch VM list"
        exit $EXIT_API_ERROR
    fi
    
    echo ""
}

cmd_vm_info() {
    local vm_id="$1"
    check_authenticated
    
    if [[ -z "$vm_id" ]]; then
        log_error "VM ID required"
        echo "Usage: $SCRIPT_NAME vm info <vm-id>"
        exit $EXIT_USAGE
    fi
    
    if ! check_service_running; then
        log_error "Service not running"
        exit $EXIT_ERROR
    fi
    
    if vm_info=$(api_get "/api/vms/$vm_id" 2>/dev/null); then
        echo "$vm_info" | jq -C '.' || echo "$vm_info"
    else
        log_error "Failed to fetch VM information for: $vm_id"
        exit $EXIT_API_ERROR
    fi
}

cmd_vm_cleanup() {
    check_root
    check_dependencies virsh
    
    local vm_id="${1:-}"
    local all_flag="${2:-}"
    local dry_run=false
    local force=false
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --all)
                all_flag="--all"
                shift
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            --force)
                force=true
                shift
                ;;
            *)
                if [[ -z "$vm_id" ]]; then
                    vm_id="$1"
                fi
                shift
                ;;
        esac
    done
    
    echo ""
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}  VM Cleanup${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo ""
    
    # Check for vm-cleanup.sh script
    local cleanup_script="/usr/local/bin/vm-cleanup.sh"
    if [[ ! -f "$cleanup_script" ]]; then
        log_error "VM cleanup script not found: $cleanup_script"
        exit $EXIT_ERROR
    fi
    
    # Build command
    local cmd="$cleanup_script"
    
    if [[ "$all_flag" == "--all" ]]; then
        cmd="$cmd --all"
    elif [[ -n "$vm_id" ]]; then
        cmd="$cmd --vm $vm_id"
    else
        log_error "Must specify either VM ID or --all"
        echo "Usage: $SCRIPT_NAME vm cleanup <vm-id>"
        echo "       $SCRIPT_NAME vm cleanup --all"
        exit $EXIT_USAGE
    fi
    
    [[ "$dry_run" == true ]] && cmd="$cmd --dry-run"
    [[ "$force" == true ]] && cmd="$cmd --force"
    
    # Execute cleanup
    log_debug "Running: $cmd"
    exec $cmd
}

# ============================================================================
# SERVICE MANAGEMENT COMMANDS
# ============================================================================

cmd_start() {
    check_root
    
    log_info "Starting DeCloud node agent..."
    
    if systemctl start "$SERVICE_NAME"; then
        log_success "Service started"
        
        # Wait a moment for service to initialize
        sleep 2
        
        if systemctl is-active --quiet "$SERVICE_NAME"; then
            log_success "Service is running"
        else
            log_error "Service failed to start"
            log_info "Check logs with: journalctl -u $SERVICE_NAME -n 50"
            exit $EXIT_ERROR
        fi
    else
        log_error "Failed to start service"
        exit $EXIT_ERROR
    fi
}

cmd_stop() {
    check_root
    
    log_info "Stopping DeCloud node agent..."
    
    if systemctl stop "$SERVICE_NAME"; then
        log_success "Service stopped"
    else
        log_error "Failed to stop service"
        exit $EXIT_ERROR
    fi
}

cmd_restart() {
    check_root
    
    log_info "Restarting DeCloud node agent..."
    
    if systemctl restart "$SERVICE_NAME"; then
        log_success "Service restarted"
        
        # Wait a moment for service to initialize
        sleep 2
        
        if systemctl is-active --quiet "$SERVICE_NAME"; then
            log_success "Service is running"
        else
            log_error "Service failed to start"
            log_info "Check logs with: journalctl -u $SERVICE_NAME -n 50"
            exit $EXIT_ERROR
        fi
    else
        log_error "Failed to restart service"
        exit $EXIT_ERROR
    fi
}

cmd_reset() {
    check_root
    
    local force=false
    local keep_vms=false
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force)
                force=true
                shift
                ;;
            --keep-vms)
                keep_vms=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    echo ""
    echo -e "${RED}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}  ⚠️  DESTRUCTIVE OPERATION - NODE RESET${NC}"
    echo -e "${RED}═══════════════════════════════════════════════════════════${NC}"
    echo ""
    echo -e "${YELLOW}This will perform the following actions:${NC}"
    echo ""
    echo "  1. Stop the node agent service"
    echo "  2. Remove authentication credentials"
    echo "  3. Clear all node agent logs"
    if [[ "$keep_vms" == false ]]; then
        echo "  4. Delete ALL virtual machines and their data"
        echo "  5. Restart the node agent service"
    else
        echo "  4. Keep VMs intact (--keep-vms specified)"
        echo "  5. Restart the node agent service"
    fi
    echo ""
    echo -e "${RED}WARNING: This action is IRREVERSIBLE!${NC}"
    echo ""
    
    if [[ "$force" == false ]]; then
        echo -e "${YELLOW}You will need to re-authenticate after reset.${NC}"
        echo ""
        read -p "Type 'RESET' to confirm this action: " confirmation
        
        if [[ "$confirmation" != "RESET" ]]; then
            log_info "Reset cancelled"
            exit 0
        fi
    fi
    
    echo ""
    log_info "Starting node reset..."
    echo ""
    
    # Disable errexit for reset operation - we want to continue even if steps fail
    set +e
    
    # Step 1: Stop service
    log_info "[1/5] Stopping node agent service..."
    if systemctl stop "$SERVICE_NAME" 2>/dev/null; then
        log_success "Service stopped"
    else
        log_warn "Service was not running"
    fi
    sleep 2
    
    # Step 2: Remove credentials
    log_info "[2/5] Removing authentication credentials..."
    local creds_removed=0
    
    if [[ -f "$CREDENTIALS_FILE" ]]; then
        rm -f "$CREDENTIALS_FILE" 2>/dev/null || true
        log_success "Credentials removed"
        ((creds_removed++))
    fi
    
    if [[ -f "$PENDING_AUTH_FILE" ]]; then
        rm -f "$PENDING_AUTH_FILE" 2>/dev/null || true
        log_success "Pending auth removed"
        ((creds_removed++))
    fi
    
    if [[ $creds_removed -eq 0 ]]; then
        log_info "No credentials found"
    fi
    
    # Step 3: Clear logs
    log_info "[3/5] Clearing node agent logs..."
    if [[ -d "$LOG_DIR" ]]; then
        # Clear log files but keep directory
        find "$LOG_DIR" -type f -name "*.log" -delete 2>/dev/null || true
        log_success "Logs cleared"
    else
        log_info "No log directory found"
    fi
    
    # Also clear systemd journal for this service
    journalctl --rotate >/dev/null 2>&1 || true
    journalctl --vacuum-time=1s >/dev/null 2>&1 || true
    log_success "Systemd journal vacuumed"
    
    # Step 4: Clean up VMs
    if [[ "$keep_vms" == false ]]; then
        log_info "[4/5] Cleaning up ALL virtual machines..."
        
        # Check if vm-cleanup.sh exists
        if [[ -f "/usr/local/bin/vm-cleanup.sh" ]]; then
            # Use vm-cleanup.sh script
            /usr/local/bin/vm-cleanup.sh --all --force >/dev/null 2>&1 || {
                log_warn "VM cleanup script encountered errors (may be OK)"
            }
            log_success "All VMs cleaned up via vm-cleanup.sh"
        else
            # Fallback: manual cleanup
            log_warn "vm-cleanup.sh not found, performing manual cleanup..."
            
            # Stop and undefine all VMs
            local vm_count=0
            local vm_list=$(virsh list --all --uuid 2>/dev/null || echo "")
            
            if [[ -n "$vm_list" ]]; then
                while IFS= read -r vm_id; do
                    if [[ -n "$vm_id" ]]; then
                        virsh destroy "$vm_id" 2>/dev/null || true
                        virsh undefine "$vm_id" --remove-all-storage 2>/dev/null || true
                        ((vm_count++))
                    fi
                done <<< "$vm_list"
            fi
            
            # Clean VM storage directory
            if [[ -d "$VM_STORAGE_PATH" ]]; then
                rm -rf "${VM_STORAGE_PATH:?}"/* 2>/dev/null || true
            fi
            
            log_success "Cleaned up $vm_count VMs manually"
        fi
    else
        log_info "[4/5] Skipping VM cleanup (--keep-vms specified)"
    fi
    
    # Step 5: Restart service
    log_info "[5/5] Restarting node agent service..."
    if systemctl start "$SERVICE_NAME" 2>/dev/null; then
        sleep 3
        
        if systemctl is-active --quiet "$SERVICE_NAME" 2>/dev/null; then
            log_success "Service restarted successfully"
        else
            log_error "Service failed to start"
            log_info "Check logs with: journalctl -u $SERVICE_NAME -n 50"
        fi
    else
        log_error "Failed to restart service"
        log_info "Try manually: sudo systemctl start $SERVICE_NAME"
    fi
    
    # Re-enable errexit
    set -e
    
    echo ""
    echo -e "${GREEN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}  Reset Complete!${NC}"
    echo -e "${GREEN}═══════════════════════════════════════════════════════════${NC}"
    echo ""
    echo "Node has been reset to factory state."
    echo ""
    echo "Next steps:"
    echo "  1. Re-authenticate: ${BOLD}sudo $SCRIPT_NAME login${NC}"
    echo "  2. Check status:    ${BOLD}$SCRIPT_NAME status${NC}"
    echo "  3. Monitor logs:    ${BOLD}$SCRIPT_NAME logs -f${NC}"
    echo ""
}

cmd_logs() {
    local subcommand=""
    local lines="${1:-50}"
    local follow=false
    local source="file"  # file or journal
    
    # Check if first argument is a subcommand
    if [[ $# -gt 0 ]] && [[ "$1" != -* ]]; then
        subcommand="$1"
        shift
    fi
    
    # Handle subcommands
    case "$subcommand" in
        clear|empty)
            cmd_logs_clear "$@"
            return
            ;;
        view|"")
            # Continue to view logs (default behavior)
            ;;
        *)
            log_error "Unknown logs subcommand: $subcommand"
            echo "Usage: $SCRIPT_NAME logs [view|clear] [options]"
            exit $EXIT_USAGE
            ;;
    esac
    
    # Parse options for log viewing
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -f|--follow)
                follow=true
                shift
                ;;
            -n|--lines)
                lines="$2"
                shift 2
                ;;
            --journal)
                source="journal"
                shift
                ;;
            --file)
                source="file"
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    # Display logs based on source
    if [[ "$source" == "journal" ]]; then
        # Show journalctl logs
        if [[ "$follow" == true ]]; then
            exec journalctl -u "$SERVICE_NAME" -f
        else
            exec journalctl -u "$SERVICE_NAME" -n "$lines" --no-pager
        fi
    else
        # Show file-based logs (default)
        if [[ ! -f "$LOG_FILE" ]]; then
            log_warn "Log file not found: $LOG_FILE"
            echo ""
            echo "The service may be logging to systemd journal instead."
            echo "Try: $SCRIPT_NAME logs --journal"
            exit $EXIT_ERROR
        fi
        
        if [[ "$follow" == true ]]; then
            exec tail -f "$LOG_FILE"
        else
            exec tail -n "$lines" "$LOG_FILE"
        fi
    fi
}

cmd_logs_clear() {
    check_root
    
    local before_last_start=false
    local force=false
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --before-last-start)
                before_last_start=true
                shift
                ;;
            --force)
                force=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    echo ""
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    if [[ "$before_last_start" == true ]]; then
        echo -e "${BOLD}  Clear Logs Before Last Service Start${NC}"
    else
        echo -e "${BOLD}  Clear All Node Agent Logs${NC}"
    fi
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo ""
    
    if [[ "$before_last_start" == true ]]; then
        echo -e "${YELLOW}This will clear all logs from before the last service start.${NC}"
        echo "Recent logs (since last service start) will be preserved."
    else
        echo -e "${YELLOW}This will clear ALL node agent logs:${NC}"
        echo ""
        echo "  • Node agent log file: $LOG_FILE"
        echo "  • Other logs in $LOG_DIR"
        echo "  • Systemd journal logs for $SERVICE_NAME"
        echo ""
        echo -e "${RED}WARNING: This action cannot be undone!${NC}"
    fi
    echo ""
    
    if [[ "$force" == false ]]; then
        if [[ "$before_last_start" == true ]]; then
            read -p "Clear logs before last start? [y/N]: " confirmation
        else
            read -p "Clear ALL logs? [y/N]: " confirmation
        fi
        
        if [[ ! "$confirmation" =~ ^[Yy]$ ]]; then
            log_info "Operation cancelled"
            exit 0
        fi
    fi
    
    echo ""
    log_info "Clearing logs..."
    echo ""
    
    # Disable errexit for log clearing - we want to continue even if steps fail
    set +e
    
    if [[ "$before_last_start" == true ]]; then
        # Get the timestamp of the last service start
        local last_start=$(systemctl show -p ActiveEnterTimestamp "$SERVICE_NAME" | cut -d= -f2)
        
        if [[ -z "$last_start" || "$last_start" == "0" || "$last_start" == "n/a" ]]; then
            log_warn "Could not determine last service start time"
            log_info "Service may not be running or has never started"
            echo ""
            
            # Re-enable errexit
            set -e
            exit $EXIT_ERROR
        fi
        
        log_info "Last service start: $last_start"
        echo ""
        
        # Clear systemd journal logs before last start
        log_info "Clearing systemd journal logs before last start..."
        
        journalctl --rotate >/dev/null 2>&1 || true
        
        # Get journal size before cleanup
        local before_size=$(journalctl -u "$SERVICE_NAME" --disk-usage 2>/dev/null | grep -oP '\d+\.\d+[KMGT]' | head -1 || echo "unknown")
        
        # Calculate time since last start
        local last_start_epoch=$(date -d "$last_start" +%s 2>/dev/null || echo "0")
        local current_epoch=$(date +%s)
        local time_diff=$((current_epoch - last_start_epoch))
        
        if [[ "$time_diff" -gt 0 ]]; then
            local days_ago=$((time_diff / 86400))
            local hours_ago=$(((time_diff % 86400) / 3600))
            
            log_info "Service has been running for ${days_ago}d ${hours_ago}h"
            
            # Vacuum logs older than the last start time
            local vacuum_time="${time_diff}s"
            
            if journalctl -u "$SERVICE_NAME" --vacuum-time="${vacuum_time}" >/dev/null 2>&1; then
                log_success "Systemd journal logs cleared before last start"
            else
                log_warn "Could not clear systemd journal (may require elevated privileges)"
            fi
        else
            log_warn "Could not calculate time difference for log cleanup"
        fi
        
        # Note: File-based logs don't have timestamps, so we can't clear only old entries
        log_info "Note: File-based logs in $LOG_DIR are not affected"
        log_info "Use 'decloud logs clear' to clear all file logs if needed"
        
    else
        # Clear ALL logs
        
        # Step 1: Clear node agent log file
        log_info "[1/3] Clearing node agent log file..."
        if [[ -f "$LOG_FILE" ]]; then
            local file_size=$(du -h "$LOG_FILE" 2>/dev/null | cut -f1 || echo "unknown")
            if > "$LOG_FILE" 2>/dev/null; then
                log_success "Cleared $LOG_FILE (was: $file_size)"
            else
                log_warn "Could not clear $LOG_FILE"
            fi
        else
            log_info "Log file $LOG_FILE does not exist"
        fi
        
        # Step 2: Clear other log files in directory
        log_info "[2/3] Clearing other log files in $LOG_DIR..."
        local files_cleared=0
        
        if [[ -d "$LOG_DIR" ]]; then
            # Find and delete other log files (excluding the main nodeagent.log which we already cleared)
            local log_files=$(find "$LOG_DIR" -type f \( -name "*.log.*" -o -name "audit.log*" \) 2>/dev/null || echo "")
            
            if [[ -n "$log_files" ]]; then
                while IFS= read -r log_file; do
                    if [[ -n "$log_file" ]]; then
                        rm -f "$log_file" 2>/dev/null && ((files_cleared++)) || true
                    fi
                done <<< "$log_files"
                
                if [[ $files_cleared -gt 0 ]]; then
                    log_success "Cleared $files_cleared additional file(s) from $LOG_DIR"
                fi
            else
                log_info "No additional log files found in $LOG_DIR"
            fi
        else
            log_info "Log directory $LOG_DIR does not exist"
        fi
        
        # Step 3: Clear systemd journal
        log_info "[3/3] Clearing systemd journal logs..."
        
        # Get journal size before cleanup
        local before_size=$(journalctl -u "$SERVICE_NAME" --disk-usage 2>/dev/null | grep -oP '\d+\.\d+[KMGT]' | head -1 || echo "unknown")
        
        # Rotate journal to close current log file
        journalctl --rotate >/dev/null 2>&1 || true
        
        # Vacuum all old logs (keep only 1 second of logs, effectively clearing all)
        if journalctl -u "$SERVICE_NAME" --vacuum-time=1s >/dev/null 2>&1; then
            local after_size=$(journalctl -u "$SERVICE_NAME" --disk-usage 2>/dev/null | grep -oP '\d+\.\d+[KMGT]' | head -1 || echo "unknown")
            log_success "Systemd journal cleared (was: $before_size, now: $after_size)"
        else
            log_warn "Could not clear systemd journal (may require elevated privileges)"
        fi
    fi
    
    # Re-enable errexit
    set -e
    
    echo ""
    echo -e "${GREEN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}  Log Clearing Complete!${NC}"
    echo -e "${GREEN}═══════════════════════════════════════════════════════════${NC}"
    echo ""
    
    if [[ "$before_last_start" == true ]]; then
        echo "Logs before the last service start have been cleared."
        echo "Recent logs since service start are preserved."
    else
        echo "All node agent logs have been cleared."
    fi
    echo ""
    echo "To view current logs: ${BOLD}$SCRIPT_NAME logs${NC}"
    echo "To follow logs:       ${BOLD}$SCRIPT_NAME logs -f${NC}"
    echo ""
}

# ============================================================================
# DIAGNOSTIC COMMANDS
# ============================================================================

cmd_diagnose() {
    echo ""
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}  DeCloud Node Agent Diagnostics${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo ""
    
    # 1. Check service
    echo -e "${BOLD}1. Service Status${NC}"
    if systemctl is-active --quiet "$SERVICE_NAME"; then
        log_success "Service is running"
    else
        log_error "Service is not running"
        echo "  Start with: sudo $SCRIPT_NAME start"
    fi
    echo ""
    
    # 2. Check authentication
    echo -e "${BOLD}2. Authentication${NC}"
    if [[ -f "$CREDENTIALS_FILE" ]]; then
        log_success "Credentials file exists"
        
        local node_id=$(get_node_id)
        if [[ -n "$node_id" ]]; then
            echo "  Node ID: $node_id"
        else
            log_warn "Node ID not found in credentials"
        fi
    else
        log_error "Not authenticated"
        echo "  Run: sudo $SCRIPT_NAME login"
    fi
    echo ""
    
    # 3. Check libvirt
    echo -e "${BOLD}3. Virtualization (libvirt)${NC}"
    if command -v virsh &>/dev/null; then
        log_success "virsh command available"
        
        if systemctl is-active --quiet libvirtd; then
            log_success "libvirtd service is running"
        else
            log_error "libvirtd service is not running"
            echo "  Start with: sudo systemctl start libvirtd"
        fi
        
        # Check VM count
        local vm_count=$(virsh list --all --uuid 2>/dev/null | grep -v '^$' | wc -l)
        echo "  VMs in libvirt: $vm_count"
    else
        log_error "virsh not found (libvirt not installed)"
    fi
    echo ""
    
    # 4. Check WireGuard
    echo -e "${BOLD}4. WireGuard${NC}"
    if command -v wg &>/dev/null; then
        log_success "wg command available"
        
        if wg show &>/dev/null; then
            local interfaces=$(wg show interfaces)
            if [[ -n "$interfaces" ]]; then
                log_success "WireGuard interfaces active"
                echo "  Interfaces: $interfaces"
            else
                log_warn "No WireGuard interfaces active"
            fi
        else
            log_warn "Cannot query WireGuard (may need root)"
        fi
    else
        log_error "WireGuard not installed"
    fi
    echo ""
    
    # 5. Check network connectivity
    echo -e "${BOLD}5. Network Connectivity${NC}"
    if check_service_running && [[ -f "$CREDENTIALS_FILE" ]]; then
        if status=$(api_get "/api/node/network/status" 2>/dev/null); then
            local internet=$(echo "$status" | jq -r '.isInternetReachable // "unknown"' 2>/dev/null)
            local orchestrator=$(echo "$status" | jq -r '.isOrchestratorReachable // "unknown"' 2>/dev/null)
            
            if [[ "$internet" == "true" ]]; then
                log_success "Internet reachable"
            else
                log_error "Internet unreachable"
            fi
            
            if [[ "$orchestrator" == "true" ]]; then
                log_success "Orchestrator reachable"
            else
                log_error "Orchestrator unreachable"
            fi
        else
            log_warn "Cannot fetch heartbeat data"
        fi
    else
        log_warn "Cannot check (service not running or not authenticated)"
    fi
    echo ""
    
    # 6. Check disk space
    echo -e "${BOLD}6. Disk Space${NC}"
    if [[ -d "$VM_STORAGE_PATH" ]]; then
        local usage=$(df -h "$VM_STORAGE_PATH" | tail -1 | awk '{print $5}')
        local available=$(df -h "$VM_STORAGE_PATH" | tail -1 | awk '{print $4}')
        echo "  VM Storage: $usage used, $available available"
        
        # Warning if > 80% used
        local usage_percent=$(echo "$usage" | tr -d '%')
        if [[ "$usage_percent" -gt 80 ]]; then
            log_warn "Disk space usage is high (${usage})"
        else
            log_success "Disk space OK (${usage})"
        fi
    else
        log_warn "VM storage directory not found: $VM_STORAGE_PATH"
    fi
    echo ""
    
    # 7. Check recent errors
    echo -e "${BOLD}7. Recent Errors${NC}"
    local error_count=$(journalctl -u "$SERVICE_NAME" --since "10 minutes ago" -p err --no-pager 2>/dev/null | grep -c "." || echo "0")
    if [[ "$error_count" -gt 0 ]]; then
        log_warn "Found $error_count errors in last 10 minutes"
        echo "  View with: $SCRIPT_NAME logs -n 50"
    else
        log_success "No recent errors"
    fi
    echo ""
    
    # Summary
    echo -e "${BOLD}Diagnostic Summary:${NC}"
    echo "  Run '$SCRIPT_NAME status' for current status"
    echo "  Run '$SCRIPT_NAME logs' to view service logs"
    echo ""
}

cmd_test_api() {
    echo ""
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}  Node Agent API Test${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo ""
    
    local endpoints=(
        "/health"
        "/api/node"
        "/api/node/cpu"
        "/api/node/memory"
        "/api/node/storage"
    )
    
    for endpoint in "${endpoints[@]}"; do
        echo -n "Testing $endpoint ... "
        
        if response=$(api_get "$endpoint" 2>/dev/null); then
            log_success "OK"
            [[ "${VERBOSE:-0}" == "1" ]] && echo "$response" | jq -C '.'
        else
            log_error "FAILED"
        fi
    done
    
    echo ""
}

# ============================================================================
# HELP & VERSION
# ============================================================================

cmd_version() {
    echo "DeCloud Node Agent CLI v$VERSION"
}

cmd_help() {
    cat << EOF
${BOLD}DeCloud Node Agent CLI${NC}

A unified command-line tool for managing DeCloud node agent operations.

${BOLD}USAGE:${NC}
    $SCRIPT_NAME <command> [options]

${BOLD}AUTHENTICATION COMMANDS:${NC}
    login               Authenticate node with wallet signature
    logout              Remove node authentication
    status              Show comprehensive node status

${BOLD}INFORMATION COMMANDS:${NC}
    info                Display detailed node information
    resources           Display resource information (CPU, memory, storage)
    heartbeat           Display last heartbeat data
    version             Display CLI version

${BOLD}ORCHESTRATOR DIAGNOSTICS:${NC}
    performance         Show performance evaluation and tier eligibility
    capacity            Show capacity, compute points, and VM allocations
    config              Show node scheduling configuration
    node                Show node summary from orchestrator's perspective
    evaluate            Request performance re-evaluation from orchestrator

${BOLD}VM MANAGEMENT:${NC}
    vm list             List all VMs on this node
    vm info <vm-id>     Display detailed VM information
    vm cleanup <vm-id>  Clean up a specific VM
    vm cleanup --all    Clean up all VMs (with confirmation)

${BOLD}SERVICE MANAGEMENT:${NC}
    start               Start the node agent service
    stop                Stop the node agent service
    restart             Restart the node agent service
    reset               Reset node to factory state (DESTRUCTIVE!)
        --force             Skip confirmation prompt
        --keep-vms          Don't delete VMs during reset
    logs [subcommand] [options]
                        Manage node agent logs
        view (default)      View logs from $LOG_FILE
            -f, --follow        Follow log output in real-time
            -n, --lines <n>     Number of lines to show (default: 50)
            --journal           View systemd journal instead of file logs
            --file              View file logs (default)
        clear               Clear all logs (DESTRUCTIVE!)
            --before-last-start Clear only logs before last service start
            --force             Skip confirmation prompt

${BOLD}DIAGNOSTIC COMMANDS:${NC}
    diagnose            Run comprehensive diagnostics
    test-api            Test node agent API endpoints

${BOLD}OPTIONS:${NC}
    -h, --help          Display this help message
    -v, --version       Display version information
    --debug             Enable debug output

${BOLD}EXAMPLES:${NC}
    # Authenticate node
    sudo $SCRIPT_NAME login

    # Check node status
    $SCRIPT_NAME status

    # View service logs (last 50 lines)
    $SCRIPT_NAME logs

    # Follow logs in real-time
    $SCRIPT_NAME logs -f
    
    # View systemd journal instead
    $SCRIPT_NAME logs --journal -f

    # Clear all logs
    sudo $SCRIPT_NAME logs clear

    # Clear only old logs (keep logs since last service start)
    sudo $SCRIPT_NAME logs clear --before-last-start

    # List VMs
    $SCRIPT_NAME vm list

    # Clean up specific VM
    sudo $SCRIPT_NAME vm cleanup abc-123-def

    # Run diagnostics
    $SCRIPT_NAME diagnose

    # Check tier eligibility and performance
    $SCRIPT_NAME performance

    # View compute points allocation
    $SCRIPT_NAME capacity

    # Request performance re-evaluation
    $SCRIPT_NAME evaluate

    # View node from orchestrator perspective
    $SCRIPT_NAME node

    # Reset node to factory state (removes auth, cleans VMs, clears logs)
    sudo $SCRIPT_NAME reset

${BOLD}ENVIRONMENT VARIABLES:${NC}
    DEBUG=1             Enable debug output
    NODE_AGENT_URL      Override node agent URL (default: http://localhost:5100)

${BOLD}FILES:${NC}
    $CREDENTIALS_FILE
    $PENDING_AUTH_FILE
    $VM_STORAGE_PATH

${BOLD}SEE ALSO:${NC}
    journalctl(1), systemctl(1), virsh(1)

For more information, visit: https://docs.decloud.io

EOF
}

# ============================================================================
# COMMAND ROUTER
# ============================================================================

main() {
    # Parse global options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --debug)
                export DEBUG=1
                shift
                ;;
            -h|--help|help)
                cmd_help
                exit $EXIT_SUCCESS
                ;;
            -v|--version)
                cmd_version
                exit $EXIT_SUCCESS
                ;;
            -*)
                log_error "Unknown option: $1"
                echo "Run '$SCRIPT_NAME --help' for usage information"
                exit $EXIT_USAGE
                ;;
            *)
                break
                ;;
        esac
    done
    
    # Require command
    if [[ $# -eq 0 ]]; then
        cmd_help
        exit $EXIT_USAGE
    fi
    
    # Route command
    local command="$1"
    shift
    
    case "$command" in
        # Authentication
        login)
            cmd_login "$@"
            ;;
        logout)
            cmd_logout "$@"
            ;;
        
        # Status & Info
        status)
            cmd_status "$@"
            ;;
        info)
            cmd_info "$@"
            ;;
        resources)
            cmd_resources "$@"
            ;;
        heartbeat)
            cmd_heartbeat "$@"
            ;;
        
        # Orchestrator Diagnostics
        performance|perf)
            cmd_performance "$@"
            ;;
        capacity|cap)
            cmd_capacity "$@"
            ;;
        config)
            cmd_node_config "$@"
            ;;
        node)
            cmd_node_summary "$@"
            ;;
        evaluate|eval)
            cmd_evaluate "$@"
            ;;
        
        # VM Management
        vm)
            if [[ $# -eq 0 ]]; then
                log_error "VM subcommand required"
                echo "Usage: $SCRIPT_NAME vm <list|info|cleanup>"
                exit $EXIT_USAGE
            fi
            
            local vm_command="$1"
            shift
            
            case "$vm_command" in
                list|ls)
                    cmd_vm_list "$@"
                    ;;
                info|show)
                    cmd_vm_info "$@"
                    ;;
                cleanup|clean|delete|rm)
                    cmd_vm_cleanup "$@"
                    ;;
                *)
                    log_error "Unknown VM command: $vm_command"
                    echo "Valid commands: list, info, cleanup"
                    exit $EXIT_USAGE
                    ;;
            esac
            ;;
        
        # Service Management
        start)
            cmd_start "$@"
            ;;
        stop)
            cmd_stop "$@"
            ;;
        restart)
            cmd_restart "$@"
            ;;
        reset)
            cmd_reset "$@"
            ;;
        logs)
            cmd_logs "$@"
            ;;
        
        # Diagnostics
        diagnose|diag)
            cmd_diagnose "$@"
            ;;
        test-api)
            cmd_test_api "$@"
            ;;
        
        # Version
        version)
            cmd_version
            ;;
        
        # Unknown command
        *)
            log_error "Unknown command: $command"
            echo "Run '$SCRIPT_NAME --help' for usage information"
            exit $EXIT_USAGE
            ;;
    esac
}

# ============================================================================
# ENTRY POINT
# ============================================================================

# Trap errors
trap 'log_error "Command failed with exit code $?"' ERR

# Run main
main "$@"
